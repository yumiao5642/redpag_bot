=== scripts/apply_assistant_patch.sh ===
#!/usr/bin/env bash
set -euo pipefail
PATCH=${1:-assistant.patch}
test -f "$PATCH" || { echo "缺少补丁文件 $PATCH"; exit 1; }
git checkout -b assistant/local-$(date +%s)
git apply --whitespace=fix "$PATCH"
git add -A
git commit -m "chore: apply assistant patch locally"
git push -u origin HEAD
echo ">> 已推送到远端，建议发起 PR 合并。"


=== scripts/audit_repo.py ===
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
redpag_bot 本地体检脚本
逐项检查以下落地情况（打印 ✅/❌）：
  1. 充值成功后刷新页：到账金额+当前余额、二维码缩放叠字、CODE复制样式（弹窗）
  2. “我的钱包”不再显示“充值地址（专属）”
  3. 操作结束后回显主菜单（统一 show_main_menu）
  4. 功能锁：红包/提现入口拦截（sys_flags.lock_redpacket / lock_withdraw）
  5. 金额显示两位小数（fmt_amount）
  6. Bot Menu：set_my_commands / chat menu
  7. 充值直接弹窗（reply_photo + InlineKeyboard）
  8. 仅处理私聊（filters.ChatType.PRIVATE）
  9. 地址查询：TRX/USDT余额、资源、最近10笔转账；非法格式提示
 10. 九宫格交易密码
 11. 红包类型可切换（随机|平均|专属）并有“当前选中”指示
 12. 归集成功后：私聊用户通知 + 对账锁（聚合地址 USDT vs 用户总余额）
"""
import pathlib, re

ROOT = pathlib.Path(__file__).resolve().parents[1]
SRC = ROOT / "src"

def ok(msg): print("✅", msg)
def ng(msg): print("❌", msg)

def rd(p: pathlib.Path) -> str:
    try:
        return p.read_text(encoding="utf-8")
    except Exception:
        return ""

def has(p: pathlib.Path, *pats) -> bool:
    s = rd(p)
    return s and all(re.search(x, s, re.S) for x in pats)

# 1 充值成功展示
def check_recharge_success():
    p = SRC / "handlers" / "recharge.py"
    s = rd(p)
    if not s: return ng("缺文件：src/handlers/recharge.py")
    a = ("recharge_status" in s) and (("到账金额" in s) or ("get_ledger_amount_by_ref" in s) or ("ledger" in s))
    b = ("reply_photo" in s and ("make_qr_png_bytes" in s or "qrcode" in s))
    c = ("点击复制" in s and "`" in s)
    if a: ok("充值成功显示到账金额+当前余额 OK")
    else: ng("充值成功页未检测到 到账金额/余额 刷新")
    if b: ok("充值弹窗/二维码缩放 OK")
    else: ng("充值未见弹窗或二维码缩放")
    if c: ok("地址/订单号 CODE 样式 OK")
    else: ng("未检测到 CODE 样式 ‘`...`  👈 点击复制’")

# 2 钱包页不显示“充值地址（专属）”
def check_wallet_page():
    p = SRC / "handlers" / "wallet.py"
    s = rd(p)
    if not s: return ng("缺文件：src/handlers/wallet.py")
    if ("充值地址" in s and "专属" in s):
        ng("我的钱包仍出现“充值地址（专属）”字样")
    else:
        ok("我的钱包未显示“充值地址（专属）” OK")

# 3 操作结束回显主菜单
def check_show_menu():
    any_hit = False
    for name in ["recharge.py","addr_query.py","red_packet.py","withdraw.py","password.py","wallet.py"]:
        p = SRC / "handlers" / name
        if p.exists() and "show_main_menu" in rd(p):
            any_hit = True; break
    if any_hit:
        ok("结束后回显主菜单（show_main_menu）已在多个 handler 使用")
    else:
        ng("未检测到 show_main_menu 用于回显主菜单")

# 4 功能锁
def check_feature_locks():
    rp = SRC / "handlers" / "red_packet.py"
    wd = SRC / "handlers" / "withdraw.py"
    rp_ok = rp.exists() and ("lock_redpacket" in rd(rp))
    wd_ok = wd.exists() and ("lock_withdraw" in rd(wd))
    if rp_ok and wd_ok:
        ok("功能锁入口拦截（红包/提现）OK")
    else:
        ng("功能锁入口拦截存在缺口（检查 get_flag('lock_*')）")

# 5 金额统一两位小数
def check_fmt_amount():
    common = SRC / "handlers" / "common.py"
    s = rd(common)
    if s and ("def fmt_amount" in s and ".2f" in s):
        ok("fmt_amount 两位小数 OK")
    else:
        ng("未检测到 fmt_amount 或未统一两位小数（handlers/common.py）")

# 6 Bot Menu
def check_menu_register():
    p = SRC / "main.py"
    s = rd(p)
    if s and ("set_my_commands" in s or "set_chat_menu_button" in s):
        ok("Bot Menu 注册 OK")
    else:
        ng("未检测到 set_my_commands / set_chat_menu_button")

# 7 充值弹窗
def check_popup_recharge():
    p = SRC / "handlers" / "recharge.py"
    s = rd(p)
    if s and ("reply_photo" in s and "InlineKeyboard" in s):
        ok("充值弹窗（二维码+按钮）OK")
    else:
        ng("充值弹窗未检测到 reply_photo/InlineKeyboard")

# 8 仅私聊
def check_private_only():
    p = SRC / "main.py"
    s = rd(p)
    if s and (re.search(r"ChatType\\.?PRIVATE", s) or "filters.ChatType.PRIVATE" in s):
        ok("仅处理私聊 OK")
    else:
        ng("未检测到仅私聊过滤（filters.ChatType.PRIVATE）")

# 9 地址查询增强
def check_addr_query():
    p = SRC / "handlers" / "addr_query.py"
    s = rd(p)
    if not s: return ng("缺文件：src/handlers/addr_query.py")
    a = ("当前仅支持TRC-20格式地址" in s) or ("当前仅支持 TRC-20 格式地址" in s)
    b = ("get_trx_balance" in s and "get_trc20_balance" in s and "get_account_resource" in s)
    c = ("get_recent_transfers" in s)
    if a and b and c:
        ok("地址查询：校验+余额+资源+最近10笔 OK")
    else:
        ng("地址查询未完全实现（或函数调用未命中）")

# 10 九宫格交易密码
def check_password_grid():
    p = SRC / "handlers" / "password.py"
    s = rd(p)
    if s and ("InlineKeyboardButton" in s and "•" in s or "●" in s):
        ok("九宫格交易密码 UI OK")
    else:
        ng("未检测到九宫格密码 UI")

# 11 红包类型切换
def check_redpacket_types():
    p = SRC / "handlers" / "red_packet.py"
    s = rd(p)
    if s and ("随机" in s and "平均" in s and "专属" in s and "set_rp_type" in s):
        ok("红包类型可切换（随机|平均|专属）OK")
    else:
        ng("红包类型切换功能未检测到（或缺少指示当前选中）")

# 12 归集成功通知 + 对账锁
def check_collector_notify_reconcile():
    p = SRC / "collectors" / "recharge_collector.py"
    s = rd(p)
    if not s: return ng("缺文件：src/collectors/recharge_collector.py")
    a = ("send_message" in s and "充值成功" in s) or ("_notify" in s and "success" in s)
    b = ("sum_user_usdt_balance" in s and "get_trc20_balance" in s and ("set_flag(\"lock_" in s or "lock_" in s))
    if a: ok("归集成功后用户通知 OK")
    else: ng("归集成功后用户通知未检测到")
    if b: ok("对账 + 锁开关 校验 OK")
    else: ng("对账/锁开关逻辑未检测到")

def main():
    print("=== redpag_bot 本地体检 ===")
    check_recharge_success()
    check_wallet_page()
    check_show_menu()
    check_feature_locks()
    check_fmt_amount()
    check_menu_register()
    check_popup_recharge()
    check_private_only()
    check_addr_query()
    check_password_grid()
    check_redpacket_types()
    check_collector_notify_reconcile()
    print("=== 体检结束 ===")

if __name__ == "__main__":
    main()


=== scripts/make_chat_bundle.sh ===
#!/usr/bin/env bash
set -euo pipefail
OUT=chat_sync_bundle.tgz
mkdir -p chat_sync
echo "Commit: $(git rev-parse HEAD)" > chat_sync/GIT_HEAD.txt
echo "Date: $(date -u +'%F %T UTC')" >> chat_sync/GIT_HEAD.txt
find src scripts -type f | sort > chat_sync/file_list.txt
> chat_sync/all_file.txt
while IFS= read -r f; do
  if file "$f" | grep -qi "text"; then
    echo "=== $f ===" >> chat_sync/all_file.txt
    cat "$f" >> chat_sync/all_file.txt
    echo -e "\n" >> chat_sync/all_file.txt
  fi
done < chat_sync/file_list.txt
if [ -f scripts/audit_repo.py ]; then
  python3 scripts/audit_repo.py > chat_sync/audit_report.txt || true
fi
tar czf "$OUT" chat_sync
echo ">> 生成完成：$OUT（请上传到聊天）"


=== scripts/repo_audit_strict.py ===
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
严格体检：
1) 扫描 py39 不兼容的 union（" | None"）
2) 统计 models.py 定义的函数/常量，并核对 handlers / services 里的 import 使用
3) 粗略找“未使用的 models 函数”
4) 捕捉裸 except、广义 except、print 调试残留
5) 触发一次 compileall（能快速发现语法/缩进等硬错误）

用法：
    python3 scripts/repo_audit_strict.py
"""
import os, re, sys, ast, compileall
from pathlib import Path
ROOT = Path(__file__).resolve().parent.parent
SRC = ROOT / "src"

def read(p: Path) -> str:
    return p.read_text(encoding="utf-8", errors="ignore")

def iter_py():
    for p in SRC.rglob("*.py"):
        if any(x in p.parts for x in ("__pycache__",)):
            continue
        yield p

def find_py39_union():
    bad = []
    rx = re.compile(r"\|\s*None\b")
    for p in iter_py():
        txt = read(p)
        for i, line in enumerate(txt.splitlines(), 1):
            if rx.search(line):
                bad.append((p, i, line.strip()))
    return bad

def ast_defs_calls_in_models(models: Path):
    txt = read(models)
    tree = ast.parse(txt, filename=str(models))
    defs = set()
    for n in ast.walk(tree):
        if isinstance(n, (ast.FunctionDef, ast.AsyncFunctionDef)):
            defs.add(n.name)
        if isinstance(n, ast.Assign):
            for t in n.targets:
                if isinstance(t, ast.Name):
                    defs.add(t.id)
    return defs

def imported_from_models():
    used = set()
    rx = re.compile(r"from\s+\.{1,2}models\s+import\s+(.+)")
    for p in iter_py():
        if p.name == "models.py":
            continue
        for m in rx.finditer(read(p)):
            names = [x.strip().split(" as ")[0] for x in m.group(1).split(",")]
            for n in names:
                if n:
                    used.add(n)
    return used

def grep_usage(name: str):
    # 粗糙：全仓文本搜索
    pat = re.compile(r"\b" + re.escape(name) + r"\b")
    hits = []
    for p in iter_py():
        for i, line in enumerate(read(p).splitlines(), 1):
            if pat.search(line):
                hits.append((p, i, line.strip()))
    return hits

def scan_broad_except():
    items = []
    rx_bare = re.compile(r"^\s*except\s*:\s*$")
    rx_broad = re.compile(r"^\s*except\s+\((Exception|BaseException)\)\s*:\s*$")
    for p in iter_py():
        for i, line in enumerate(read(p).splitlines(), 1):
            if rx_bare.match(line) or rx_broad.match(line):
                items.append((p, i, line.strip()))
    return items

def scan_prints():
    items = []
    rx = re.compile(r"^\s*print\(")
    for p in iter_py():
        for i, line in enumerate(read(p).splitlines(), 1):
            if rx.match(line):
                items.append((p, i, line.strip()))
    return items

def main():
    print("=== 严格体检（py39 兼容 & 符号核对 & 粗略死代码 & 异常规范 & 编译检查） ===")

    unions = find_py39_union()
    if unions:
        print("\n[!] 发现 py3.9 不兼容的 union 标注（请改为 Optional[...]）:")
        for p,i,l in unions:
            print(f" - {p}:{i}: {l}")
    else:
        print("\n[OK] 未发现 ' | None' 等 py39 不兼容 union")

    models = SRC / "models.py"
    if models.exists():
        defs = ast_defs_calls_in_models(models)
        used = imported_from_models()
        missing = sorted(n for n in used if n not in defs)
        if missing:
            print("\n[!] 其他模块引自 models 但 models 未定义：")
            for n in missing:
                print(f" - {n}")
        else:
            print("\n[OK] models 中能找到所有被 import 的符号")

        # 粗略“未被使用”的定义（排除常见保留）
        ignore = {"__all__", "__version__", "__doc__"}
        unused = []
        for name in sorted(d for d in defs if not d.startswith("_") and d not in ignore):
            hits = grep_usage(name)
            # 仅在 models 自身被定义，不在其他处被引用
            if all(str(p).endswith("/models.py") for p,_,_ in hits):
                unused.append(name)
        if unused:
            print("\n[?] 可能未使用的 models 符号（请人工复核，某些可能供 SQL/反射调用）：")
            for n in unused:
                print(f" - {n}")
        else:
            print("\n[OK] 未发现明显未使用的 models 符号")

    excs = scan_broad_except()
    if excs:
        print("\n[!] 发现裸/过宽 except（建议改为精确异常/加日志）：")
        for p,i,l in excs:
            print(f" - {p}:{i}: {l}")
    else:
        print("\n[OK] 未发现裸/过宽 except")

    prints = scan_prints()
    if prints:
        print("\n[?] 发现 print 调试输出（建议改为 logger）：")
        for p,i,l in prints:
            print(f" - {p}:{i}: {l}")
    else:
        print("\n[OK] 未发现 print 调试输出")

    print("\n[*] 进行编译检查（compileall）...")
    ok = compileall.compile_dir(str(SRC), quiet=1, force=False)
    if ok:
        print("[OK] compileall 编译通过")
    else:
        print("[X] compileall 有错误（请查看上方报错并修复）")

if __name__ == "__main__":
    main()


=== src/collectors/recharge_collector.py ===
import asyncio
import time

from ..config import AGGREGATE_ADDRESS, MIN_DEPOSIT_USDT, USDT_CONTRACT
from ..db import close_pool, init_pool
from ..models import (
    add_energy_rent_log,
    add_ledger,
    has_active_energy_rent,
    ledger_exists_for_ref,
    set_flag,
    set_recharge_status,
    sum_user_usdt_balance,
)
from ..services.energy import rent_energy
from ..services.tron import get_account_resource, get_trc20_balance, get_usdt_balance

bot = Bot(BOT_TOKEN)


async def _notify_success(user_id: int, order_no: str, amt: float, new_bal: float):
    txt = (
        f"✅ 充值成功\n"
        f"订单号：`{order_no}`\n"
        f"到账金额：**{amt:.2f} USDT**\n"
        f"当前余额：**{new_bal:.2f} USDT**"
    )
    await bot.send_message(chat_id=user_id, text=txt, parse_mode="Markdown")


async def _reconcile_and_lock():
    # 聚合地址余额 vs 用户总余额
    agg = await get_trc20_balance(AGGREGATE_ADDRESS, USDT_CONTRACT)
    total = await sum_user_usdt_balance()
    # 规则：总余额 <= 聚合余额 为正常，否则锁功能
    need_lock = total > agg + 1e-8
    await set_flag("lock_withdraw", need_lock)
    await set_flag("lock_redpacket", need_lock)


EXPIRE_SQL = "UPDATE recharge_orders SET status='expired' WHERE status='waiting' AND expire_at <= NOW()"


def _safe_notes(s: str) -> str:
    return re.sub(r"[^\u4e00-\u9fa5A-Za-z0-9_-]", "", s)


async def _wait_energy_ready(
    addr: str, need_energy: int, timeout: int = None, poll_interval: int = None
) -> bool:
    """
    轮询等待能量生效：直到能量 >= need_energy 或等待达到 timeout。
    - timeout 从环境变量 TRONGAS_ACTIVATION_DELAY 读（默认 30s）
    - poll_interval 从环境变量 TRONGAS_POLL_INTERVAL 读（默认 3s）
    """
    from ..logger import collect_logger
    from ..services.tron import get_account_resource  # 避免循环导入，放在函数内

    timeout = (
        int(os.getenv("TRONGAS_ACTIVATION_DELAY", "30"))
        if timeout is None
        else int(timeout)
    )
    poll_interval = (
        int(os.getenv("TRONGAS_POLL_INTERVAL", "3"))
        if poll_interval is None
        else int(poll_interval)
    )

    start = time.monotonic()
    # 先打一次快照
    res = get_account_resource(addr)
    if res.get("energy", 0) >= need_energy:
        used = time.monotonic() - start
        collect_logger.info(
            f"✅ 能量已就绪：{res['energy']} ≥ {need_energy}（用时 {used:.1f}s，timeout={timeout}s）"
        )
        return True

    while True:
        elapsed = time.monotonic() - start
        if elapsed >= timeout:
            collect_logger.info(
                f"⌛ 等待能量超时：{res['energy']} < {need_energy}（已等 {elapsed:.1f}s / {timeout}s）"
            )
            return False

        left = min(poll_interval, max(1, timeout - int(elapsed)))
        collect_logger.info(
            f"⏳ 等待能量生效 {int(elapsed)}s/{timeout}s：当前 {res['energy']} < {need_energy}，{left}s 后重查…"
        )
        await asyncio.sleep(left)

        # 重查资源
        res = get_account_resource(addr)
        if res.get("energy", 0) >= need_energy:
            used = time.monotonic() - start
            collect_logger.info(
                f"✅ 能量已就绪：{res['energy']} ≥ {need_energy}（用时 {used:.1f}s / {timeout}s）"
            )
            return True


def _log_resource_snapshot(
    addr: str,
    usdt_bal: float,
    res: dict,
    need_energy: int,
    need_bw: int,
    trx_bal: float,
    prefix: str = "🔎 资源快照",
):
    collect_logger.info(
        f"{prefix}：\n"
        f"  • 地址：{addr}\n"
        f"  • USDT余额：{usdt_bal:.6f}\n"
        f"  • 能量：{res['energy']} / 需要 {need_energy}\n"
        f"  • 带宽：{res['bandwidth']} / 建议 {need_bw}\n"
        f"  • TRX余额：{trx_bal:.6f}"
    )


async def _precheck_and_prepare(
    uid: int, addr: str, oid: int, order_no: str
) -> Tuple[bool, float]:
    need_energy = int(os.getenv("USDT_ENERGY_REQUIRE", "90000"))
    need_bw = int(os.getenv("MIN_BANDWIDTH", "800"))
    min_deposit = float(os.getenv("MIN_DEPOSIT_USDT", "10"))
    min_trx_for_bw = float(os.getenv("MIN_TRX_FOR_BANDWIDTH", "1.0"))
    trx_topup_target = float(os.getenv("TRX_TOPUP_TARGET", "2.0"))
    rent_retry_sec = int(os.getenv("ENERGY_RENT_RETRY_SECONDS", "120"))

    # 余额
    usdt_bal = await get_usdt_balance(addr)
    res0 = get_account_resource(addr)
    trx_bal0 = get_trx_balance(addr)
    _log_resource_snapshot(
        addr,
        usdt_bal,
        res0,
        need_energy,
        need_bw,
        trx_bal0,
        prefix="🔎 资源快照（预检前）",
    )

    if usdt_bal < min_deposit:
        collect_logger.info(
            f"⏸ USDT不足：{usdt_bal:.6f} < {min_deposit:.2f}，本轮不归集"
        )
        return False, usdt_bal

    # —— 能量保障：不足就租，哪怕已有有效租单，但 energy 仍达不到阈值，也会根据最小间隔再次租 —— #
    if res0["energy"] < need_energy:
        can_rent = True
        ago = await last_energy_rent_seconds_ago(addr)
        if ago < rent_retry_sec:
            can_rent = False
            collect_logger.info(
                f"⏳ 距离上次租能量 {ago}s < {rent_retry_sec}s，暂不重复下单（避免频繁下单）"
            )

        if can_rent:
            try:
                min_rent = int(os.getenv("TRONGAS_MIN_RENT", "32000"))
                step = max(int(os.getenv("TRONGAS_RENT_STEP", "1000")), 1)
                gap = max(need_energy - res0["energy"], min_rent)
                gap = ((gap + step - 1) // step) * step
                collect_logger.info(
                    f"⚡ 计划租能量：缺口≈{need_energy - res0['energy']}，下单量={gap}（min={min_rent}, step={step}）"
                )
                resp = await rent_energy(
                    receive_address=addr,
                    pay_nums=gap,
                    rent_time=1,
                    order_notes=f"order-{order_no}",
                )

                rid = (resp or {}).get("orderId") or (resp or {}).get("order_id")
                await add_energy_rent_log(
                    addr, oid, order_no, rent_order_id=str(rid), ttl_seconds=3600
                )
                collect_logger.info(f"⚡ 已租能量 gap≈{gap}：order_id={rid}，等待生效…")
            except Exception as e:
                collect_logger.error(f"❌ 租能量失败：{e}；先不归集")
                return False, usdt_bal

        ok = await _wait_energy_ready(
            addr, need_energy, timeout=int(os.getenv("TRONGAS_ACTIVATION_DELAY", "30"))
        )
        res1 = get_account_resource(addr)
        trx_bal1 = get_trx_balance(addr)
        _log_resource_snapshot(
            addr,
            usdt_bal,
            res1,
            need_energy,
            need_bw,
            trx_bal1,
            prefix="🔎 资源快照（租能量后）",
        )
        if res1["energy"] < need_energy:
            collect_logger.info(
                f"⏸ 能量仍不足：{res1['energy']} < {need_energy}，本轮不归集"
            )
            return False, usdt_bal
        res0 = res1
        trx_bal0 = trx_bal1

    # —— 带宽保障：放宽为“带宽≥阈值 或 TRX余额≥最小值” —— #
    if res0["bandwidth"] < need_bw and trx_bal0 < min_trx_for_bw:
        fee_from = os.getenv("FEE_PAYER_ADDRESS")
        fee_priv = os.getenv("FEE_PAYER_PRIVKEY_HEX")
        if not (fee_from and fee_priv):
            collect_logger.warning(
                f"⚠️ 带宽不足且 TRX 余额({trx_bal0:.6f})<最小值({min_trx_for_bw})，且未配置代付账号，无法保障带宽"
            )
            return False, usdt_bal

        # 代付金额 = 目标 - 当前（留出0.1安全余量）
        need_topup = max(0.0, trx_topup_target - trx_bal0 + 0.1)
        try:
            txid = send_trx(fee_priv, fee_from, addr, need_topup)
            collect_logger.info(
                f"🪙 代付 TRX {need_topup:.6f} → {addr} 成功，txid={txid}"
            )
            await asyncio.sleep(3)
        except Exception as e:
            collect_logger.error(f"❌ 代付失败：{e}；本轮不归集")
            return False, usdt_bal

        res2 = get_account_resource(addr)
        trx_bal2 = get_trx_balance(addr)
        _log_resource_snapshot(
            addr,
            usdt_bal,
            res2,
            need_energy,
            need_bw,
            trx_bal2,
            prefix="🔎 资源快照（代付后）",
        )
        # 代付后即便带宽字段仍<阈值，只要 TRX≥最小值就允许继续（靠烧费）
        if trx_bal2 < min_trx_for_bw:
            collect_logger.info(
                f"⏸ 代付后 TRX 余额仍不足：{trx_bal2:.6f} < {min_trx_for_bw}，本轮不归集"
            )
            return False, usdt_bal

    return True, usdt_bal


async def _ensure_resources(addr: str, oid: int, order_no: str) -> None:
    """确保该地址本次归集的 能量+带宽 足够；1小时内不重复租能量；带宽不足自动TRX代付"""
    res = get_account_resource(addr)
    need_energy = int(os.getenv("USDT_ENERGY_REQUIRE", "30000"))
    need_bw = int(os.getenv("MIN_BANDWIDTH", "500"))

    # —— 能量：若不足且 1h 内无有效租单则下单 —— #
    if res["energy"] < need_energy and not await has_active_energy_rent(addr):
        try:
            resp = await rent_energy(
                receive_address=addr,
                pay_nums=max(need_energy - res["energy"], 20000),  # 至少租 20k
                rent_time=1,
                order_notes=_safe_notes(f"order-{order_no}"),
            )
            order_id = (resp or {}).get("order_id")
            await add_energy_rent_log(
                addr, oid, order_no, rent_order_id=str(order_id), ttl_seconds=3600
            )
            collect_logger.info(
                f"⚡ 能量下单成功：订单 {oid}（{order_no}） id={order_id}"
            )
            await asyncio.sleep(int(os.getenv("TRONGAS_ACTIVATION_DELAY", "8")))
            ok = await _wait_energy_ready(
                addr,
                need_energy,
                timeout=int(os.getenv("TRONGAS_ACTIVATION_DELAY", "30")),
            )
            if not ok:
                collect_logger.warning(
                    f"⚠️ 能量租用已下单但未及时生效，当前 energy={get_account_resource(addr)['energy']}"
                )

        except Exception as e:
            collect_logger.error(f"❌ 能量下单失败：{e}；稍后重试")
            # 不抛出，继续检查带宽，下一轮会再试
    else:
        collect_logger.info(
            f"⚡ 能量充足或已有有效租单，跳过租能量（剩余 {res['energy']}）"
        )

    # —— 带宽：若不足，尝试 TRX 代付 —— #
    res = get_account_resource(addr)  # 再查一次
    if res["bandwidth"] < need_bw:
        fee_from = os.getenv("FEE_PAYER_ADDRESS")
        fee_priv = os.getenv("FEE_PAYER_PRIVKEY_HEX")
        topup = float(os.getenv("TOPUP_TRX", "1.2"))
        if fee_from and fee_priv and topup > 0:
            try:
                txid = send_trx(fee_priv, fee_from, addr, topup)
                collect_logger.info(
                    f"🪙 带宽不足，已从 {fee_from} 代付 {topup} TRX → {addr}，txid={txid}"
                )
                await asyncio.sleep(3)  # 让余额可见
            except Exception as e:
                collect_logger.error(f"❌ TRX 代付失败：{e}；稍后重试")
        else:
            collect_logger.warning(
                f"⚠️ 带宽不足（{res['bandwidth']} < {need_bw}），且未配置代付账号，可能导致 BANDWIDTH_ERROR"
            )
    # 代付之后
    res2 = get_account_resource(addr)
    collect_logger.info(
        f"🪙 代付后资源：带宽 {res2['bandwidth']}、能量 {res2['energy']}"
    )


async def _collect_and_book(uid: int, addr: str, oid: int, order_no: str):
    """
    1) 先确保资源（能量+带宽）
    2) 发起 USDT 全额转账到归集地址
    3) 置 verifying；记账（含幂等）
    """
    ok, bal = await _precheck_and_prepare(uid, addr, oid, order_no)
    if not ok:
        collect_logger.info(f"⏸ 订单 {oid}（{order_no}）预检未通过，跳过本轮归集")
        return None
    bal = await get_usdt_balance(addr)
    if bal <= 0:
        collect_logger.warning(f"⚠️ 订单 {oid}（{order_no}）准备归集时余额为 0，跳过")
        return None

    # 先确保资源
    await _ensure_resources(addr, oid, order_no)

    # 私钥
    wallet = await get_wallet(uid)
    priv_enc = wallet.get("tron_privkey_enc")
    if not priv_enc:
        collect_logger.error(
            f"❌ 订单 {oid}（{order_no}）用户 {uid} 无私钥记录，无法归集"
        )
        return None
    priv_hex = decrypt_text(priv_enc)

    # 尝试归集；如因带宽报错，进行一次“代付后重试”
    try:
        txid = await usdt_transfer_all(priv_hex, addr, AGGREGATE_ADDRESS, float(bal))
    except Exception as e:
        emsg = str(e).upper()
        if "BAND" in emsg or "BANDWITH_ERROR" in emsg or "BANDWIDTH" in emsg:
            collect_logger.warning(f"⛽ 首次归集带宽报错，尝试TRX代付后重试：{e}")
            await _ensure_resources(addr, oid, order_no)  # 里面会做代付
            txid = await usdt_transfer_all(
                priv_hex, addr, AGGREGATE_ADDRESS, float(bal)
            )
        else:
            collect_logger.error(
                f"❌ 订单 {oid}（{order_no}）归集转账失败：{e}；保留当前状态待重试"
            )
            return None

    # —— 推进状态 & 记账（与你现有逻辑一致，略） —— #
    await set_recharge_status(oid, "verifying", txid)
    # 幂等记账
    if not await ledger_exists_for_ref("recharge", "recharge_orders", oid):
        before = Decimal(str(wallet["usdt_trc20_balance"] or 0))
        after = before + Decimal(str(bal))
        await update_wallet_balance(uid, float(after))
        await add_ledger(
            uid,
            "recharge",
            float(bal),
            float(before),
            float(after),
            "recharge_orders",
            oid,
            "充值成功",
        )
    return txid, float(bal)


async def step_verifying(uid: int, addr: str, oid: int, order_no: str) -> bool:
    """
    verifying 步骤策略：
    - 若 ledger 已存在 → 直接 success（幂等）
    - 否则读取余额：
        * 余额≈0 → 标记 success
        * 余额 >= MIN_DEPOSIT_USDT → 回退到 collecting 并立即触发归集（租能量+转账+记账），仍保持 verifying 等下一轮确认
        * 余额 > 0 但 < 阈值 → 保持 verifying（下轮继续看）
    返回：是否已经 success
    """
    # 已记账 → 直接成功（幂等）
    if await ledger_exists_for_ref("recharge", "recharge_orders", oid):
        await set_recharge_status(oid, "success", None)
        collect_logger.info(f"✅ 订单 {oid} 已在 ledger 记账：verifying → success")
        await _notify_success(user_id, order_no, credited_amt, new_balance)
        await _reconcile_and_lock()
        return True

    after_bal = await get_usdt_balance(addr)

    # 清零 → 成功
    if after_bal <= 0.000001:
        await set_recharge_status(oid, "success", None)
        collect_logger.info(f"✅ 订单 {oid} 验证通过：verifying → success（余额≈0）")
        return True

    # 未清零，但达到阈值 → 回退并再次归集
    if float(after_bal) >= float(MIN_DEPOSIT_USDT):
        collect_logger.info(
            f"🔄 订单 {oid}（{order_no}）验证期余额仍 {after_bal:.6f} ≥ 阈值 {MIN_DEPOSIT_USDT:.2f}，回退 collecting 并重试归集"
        )
        await set_recharge_status(oid, "collecting", None)
        await _collect_and_book(uid, addr, oid, order_no)
        # 归集后仍保持 verifying，等待下一轮确认清零
        return False

    # 小额残留（< 阈值），先保持 verifying
    collect_logger.warning(
        f"⚠️ 订单 {oid} 验证仍见余额 {after_bal:.6f}（未达阈值），保持 verifying"
    )
    return False


async def process_waiting(order, counters):
    oid = order["id"]
    uid = order["user_id"]
    addr = order["address"]
    order_no = order.get("order_no") or str(oid)
    collect_logger.info(
        f"🔎 扫描 waiting 订单：id={oid} no={order_no} user={uid} addr={addr}"
    )

    bal = await get_usdt_balance(addr)
    collect_logger.info(
        f"📈 地址余额：{addr} = {bal:.6f} USDT（阈值 {MIN_DEPOSIT_USDT:.2f}）"
    )

    if float(bal) < float(MIN_DEPOSIT_USDT):
        collect_logger.info(f"⏳ 订单 {oid} 仍未达最小金额，保持 waiting")
        counters["waiting_skip"] += 1
        return

    await set_recharge_status(oid, "collecting", None)
    collect_logger.info(f"🚚 订单 {oid}（{order_no}）：waiting → collecting")
    counters["to_collecting"] += 1

    # 统一归集 + 记账
    ret = await _collect_and_book(uid, addr, oid, order_no)
    if ret is not None:
        counters["collecting_to_verifying"] += 1
        counters["ledger_add"] += 1  # 记账在 _collect_and_book 内做了幂等，这里统计一下


async def process_collecting(order, counters):
    oid = order["id"]
    uid = order["user_id"]
    addr = order["address"]
    order_no = order.get("order_no") or str(oid)
    collect_logger.info(f"🔧 续跑 collecting 订单：id={oid} no={order_no} user={uid}")

    ret = await _collect_and_book(uid, addr, oid, order_no)
    if ret is not None:
        counters["collecting_to_verifying"] += 1
        counters["ledger_add"] += 1


async def process_verifying(order, counters):
    oid = order["id"]
    uid = order["user_id"]
    addr = order["address"]
    order_no = order.get("order_no") or str(oid)
    collect_logger.info(f"🔍 续跑 verifying 订单：id={oid} no={order_no} user={uid}")
    ok = await step_verifying(uid, addr, oid, order_no)
    if ok:
        counters["verifying_to_success"] += 1


async def main_once():
    t0 = time.time()
    counters = {
        "waiting_total": 0,
        "waiting_skip": 0,
        "to_collecting": 0,
        "collecting_total": 0,
        "collecting_to_verifying": 0,
        "verifying_total": 0,
        "verifying_to_success": 0,
        "expired_to_closed": 0,
        "ledger_add": 0,
    }

    await init_pool()
    try:
        # 过期订单置为 expired
        n = await execute(EXPIRE_SQL) or 0
        counters["expired_to_closed"] = n
        collect_logger.info(f"⌛ 已处理超时订单：waiting→expired，共 {n} 条")

        # waiting
        waitings = await list_recharge_waiting()
        counters["waiting_total"] = len(waitings)
        for o in waitings:
            try:
                await process_waiting(o, counters)
            except Exception as e:
                collect_logger.exception(f"处理 waiting 订单 {o.get('id')} 异常：{e}")

        # collecting
        collings = await list_recharge_collecting()
        counters["collecting_total"] = len(collings)
        for o in collings:
            try:
                await process_collecting(o, counters)
            except Exception as e:
                collect_logger.exception(
                    f"处理 collecting 订单 {o.get('id')} 异常：{e}"
                )

        # verifying
        verifs = await list_recharge_verifying()
        counters["verifying_total"] = len(verifs)
        for o in verifs:
            try:
                await process_verifying(o, counters)
            except Exception as e:
                collect_logger.exception(f"处理 verifying 订单 {o.get('id')} 异常：{e}")

        # 汇总
        dur = time.time() - t0
        collect_logger.info(
            "📊 本轮归集扫描统计：\n"
            f"  • waiting：{counters['waiting_total']}（推进→collecting：{counters['to_collecting']}，未达阈值：{counters['waiting_skip']}）\n"
            f"  • collecting：{counters['collecting_total']}（推进→verifying：{counters['collecting_to_verifying']}）\n"
            f"  • verifying：{counters['verifying_total']}（推进→success：{counters['verifying_to_success']}）\n"
            f"  • 新增账变：{counters['ledger_add']}，本轮过期关闭：{counters['expired_to_closed']}，用时：{dur:.2f}s"
        )

    finally:
        await close_pool()


if __name__ == "__main__":
    asyncio.run(main_once())


=== src/config.py ===
import os

from dotenv import load_dotenv

load_dotenv()

BOT_TOKEN = os.getenv("BOT_TOKEN", "")
MYSQL_HOST = os.getenv("MYSQL_HOST", "127.0.0.1")
MYSQL_PORT = int(os.getenv("MYSQL_PORT", "3306"))
MYSQL_USER = os.getenv("MYSQL_USER", "hb_user")
MYSQL_PASSWORD = os.getenv("MYSQL_PASSWORD", "hb_pass")
MYSQL_DB = os.getenv("MYSQL_DB", "hb_db")

FERNET_KEY = os.getenv("FERNET_KEY", "")

# TRON / TronGrid / USDT
USDT_CONTRACT = os.getenv("USDT_CONTRACT", "")
AGGREGATE_ADDRESS = os.getenv("AGGREGATE_ADDRESS", "")
TRON_FULLNODE_URL = os.getenv("TRON_FULLNODE_URL", "https://api.trongrid.io")
TRONGRID_API_KEY = os.getenv("TRONGRID_API_KEY", "")  # 逗号分隔可配置多个，用于轮询
TRONGRID_QPS = float(
    os.getenv("TRONGRID_QPS", "10")
)  # 频率限制，默认 10 QPS（官方建议带 key 可达 ~15 QPS）
USDT_DECIMALS = int(os.getenv("USDT_DECIMALS", "6"))

# trongas 能量租用
TRONGAS_API_KEY = os.getenv("TRONGAS_API_KEY", "")

# 业务配置
MIN_DEPOSIT_USDT = float(os.getenv("MIN_DEPOSIT_USDT", "10"))
MIN_WITHDRAW_USDT = float(os.getenv("MIN_WITHDRAW_USDT", "5"))
WITHDRAW_FEE_FIXED = float(os.getenv("WITHDRAW_FEE_FIXED", "1"))
SUPPORT_CONTACT = os.getenv("SUPPORT_CONTACT", "@support")

# 基础断言
assert BOT_TOKEN, "请在 .env 中配置 BOT_TOKEN"
assert FERNET_KEY, "请在 .env 中配置 FERNET_KEY"
assert USDT_CONTRACT, "请在 .env 中配置 USDT_CONTRACT（TRC20 USDT 合约地址）"
assert AGGREGATE_ADDRESS, "请在 .env 中配置 AGGREGATE_ADDRESS（归集收款地址）"


=== src/db.py ===
from typing import Any, Dict, List, Optional, Tuple

import aiomysql

from .config import MYSQL_DB, MYSQL_HOST, MYSQL_PASSWORD, MYSQL_PORT, MYSQL_USER
from .logger import app_logger

_pool: Optional[aiomysql.Pool] = None


async def init_pool():
    global _pool
    if _pool is None:
        _pool = await aiomysql.create_pool(
            host=MYSQL_HOST,
            port=MYSQL_PORT,
            user=MYSQL_USER,
            password=MYSQL_PASSWORD,
            db=MYSQL_DB,
            autocommit=True,
            minsize=1,
            maxsize=10,
            charset="utf8mb4",
        )
        app_logger.info("✅ MySQL 连接池已初始化")


async def close_pool():
    global _pool
    if _pool is not None:
        _pool.close()
        await _pool.wait_closed()
        _pool = None
        app_logger.info("🛑 MySQL 连接池已关闭")


async def get_conn():
    assert _pool is not None, "MySQL 连接池未初始化"
    return _pool.acquire()


async def fetchone(sql: str, args: Tuple = ()) -> Optional[Dict[str, Any]]:
    async with await get_conn() as conn:
        async with conn.cursor(aiomysql.DictCursor) as cur:
            await cur.execute(sql, args)
            return await cur.fetchone()


async def fetchall(sql: str, args: Tuple = ()) -> List[Dict[str, Any]]:
    async with await get_conn() as conn:
        async with conn.cursor(aiomysql.DictCursor) as cur:
            await cur.execute(sql, args)
            return await cur.fetchall()


async def execute(sql: str, args: Tuple = ()) -> int:
    async with await get_conn() as conn:
        async with conn.cursor() as cur:
            await cur.execute(sql, args)
            return cur.lastrowid or 0


=== src/handlers/address_book.py ===
from telegram import Update
from telegram.ext import ContextTypes

from ..logger import address_logger
from ..models import add_user_address, list_user_addresses
from ..services.tron import is_valid_address

ALIA_MAX = 15

TIPS = (
    '⚠️ 请依照"地址 别名"，两者之间请用空格隔开，添加地址及其别名！ 如 :\n'
    'TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t IM-个人\n\n发送 "列表" 查看已有地址。'
)


async def address_entry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (update.message.text or "").strip()
    if text in ("列表", "list", "查看"):
        rows = await list_user_addresses(update.effective_user.id)
        if not rows:
            await update.message.reply_text("暂无常用地址。\n" + TIPS)
            return
        lines = ["常用地址列表："]
        for r in rows:
            lines.append(f"- {r['alias']}: {r['address']}")
        await update.message.reply_text("\n".join(lines))
        return

    parts = text.split()
    if len(parts) < 2:
        await update.message.reply_text("格式不正确。\n" + TIPS)
        return
    addr, alias = parts[0], " ".join(parts[1:])
    if len(alias) > ALIA_MAX:
        await update.message.reply_text(f"别名过长（>{ALIA_MAX}），请重新输入。")
        return
    if not is_valid_address(addr):
        await update.message.reply_text("TRX 地址格式不正确，请检查后重试。")
        return

    await add_user_address(update.effective_user.id, addr, alias)
    address_logger.info(
        f"📮 用户 {update.effective_user.id} 绑定地址：{addr}（{alias}）"
    )
    await update.message.reply_text('地址绑定成功！发送 "列表" 可查看。')


=== src/handlers/addr_query.py ===
from telegram import Update
from telegram.ext import ContextTypes

from ..config import USDT_CONTRACT
from ..services.tron import (
    get_account_resource,
    get_recent_transfers,
    get_trc20_balance,
    get_trx_balance,
    is_valid_address,
)
from .common import fmt_amount, show_main_menu


async def addr_query(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("请发送要校验的 TRON 地址：")
    context.user_data["addr_query_waiting"] = True


async def addr_query_ontext(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not context.user_data.pop("addr_query_waiting", False):
        return
    addr = (update.message.text or "").strip()
    ok = is_valid_address(addr)
    await update.message.reply_text(
        f"地址 {addr} 校验结果：{'✅有效' if ok else '❌无效'}。\n（链上余额查询后续接入）"
    )


async def on_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (update.message.text or "").strip()
    addr = text.split()[0]

    if not is_valid_address(addr):
        await update.message.reply_text("当前仅支持 TRC-20 格式地址，请重新输入")
        await show_main_menu(update.effective_chat.id, context)
        return

    trx = await get_trx_balance(addr)
    usdt = await get_trc20_balance(addr, USDT_CONTRACT)
    res = get_account_resource(addr)
    transfers = await get_recent_transfers(addr, limit=10)

    lines = [
        f"📮 地址：`{addr}`",
        f"TRX：{fmt_amount(trx)}",
        f"USDT：{fmt_amount(usdt)}",
        f"带宽：{res.bandwidth} / 能量：{res.energy}",
        "",
    ]
    if transfers:
        lines.append("🧾 最近 10 笔转账（简要）：")
        for t in transfers:
            direction = "↗️ 收" if t["to"].lower() == addr.lower() else "↘️ 付"
            asset = t.get("asset", "USDT")
            amt = fmt_amount(t["amount"])
            lines.append(f"{direction} {asset} {amt}  {t['hash'][:10]}…")
    else:
        lines.append("（无最近转账）")

    await update.message.reply_markdown("\n".join(lines))
    await show_main_menu(update.effective_chat.id, context)


=== src/handlers/common.py ===
from telegram import Update
from telegram.ext import ContextTypes

from ..keyboards import MAIN_MENU
from ..logger import app_logger, user_click_logger
from ..models import ensure_user, get_wallet, set_tron_wallet
from ..services.encryption import encrypt_text
from ..services.tron import generate_address


def fmt_amount(x) -> str:
    try:
        return f"{float(x):.2f}"
    except Exception:
        return str(x)


async def ensure_user_and_wallet(update: Update, context: ContextTypes.DEFAULT_TYPE):
    u = update.effective_user
    await ensure_user(u.id, u.username, u.first_name, u.last_name)
    wallet = await get_wallet(u.id)
    if not wallet or not wallet.get("tron_address"):
        addr = generate_address()
        await set_tron_wallet(u.id, addr.address, encrypt_text(addr.private_key_hex))
        app_logger.info(f"🔐 为用户 {u.id} 生成 TRON 地址: {addr.address}")
    user_click_logger.info(
        f"👆 用户 {u.id} 触发交互：{update.effective_message.text if update.effective_message else 'callback'}"
    )


async def show_main_menu(chat_id: int, context: ContextTypes.DEFAULT_TYPE):
    await context.bot.send_message(chat_id, "⬇️ 主菜单", reply_markup=MAIN_MENU)


async def end_and_menu(update, context):
    """便捷：在某些 handler 里结束后直接调用"""
    await show_main_menu(update.effective_chat.id, context)


=== src/handlers/fx.py ===
from telegram import Update
from telegram.ext import ContextTypes


# 占位：可对接第三方行情（如 CoinGecko / Binance API）
async def show_fx(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "汇率查询占位：USDT≈1 USD；可在此接入第三方行情接口。"
    )


=== src/handlers/ledger.py ===
from telegram import Update
from telegram.ext import ContextTypes

from ..models import list_ledger_recent
from .common import fmt_amount


async def show_ledger(update: Update, context: ContextTypes.DEFAULT_TYPE):
    u = update.effective_user
    rows = await list_ledger_recent(u.id, 10)
    if not rows:
        await update.message.reply_text("暂无账变记录。")
        return
    lines = ["最近10笔账变："]
    for r in rows:
        lines.append(
            f"[{r['created_at']}] {r['change_type']} 金额:{fmt_amount(r['amount'])} 余额:{fmt_amount(r['balance_after'])} 备注:{r.get('remark') or ''}"
        )
    await update.message.reply_text("\n".join(lines))


=== src/handlers/password.py ===
# src/handlers/password.py
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import ContextTypes

from ..models import has_tx_password, set_tx_password_hash
from ..services.encryption import hash_password
from .common import show_main_menu


def _kb(masked=True):
    # 0-9 九宫格 + 取消 + 显示/隐藏
    rows = []
    nums = ["0", "1", "4", "6", "9", "2", "7", "3", "5", "8"]
    for i in range(0, 9, 3):
        rows.append(
            [
                InlineKeyboardButton(nums[i + j], callback_data=f"pwd:{nums[i+j]}")
                for j in range(3)
            ]
        )
    rows.append(
        [
            InlineKeyboardButton("取消", callback_data="pwd:back"),
            InlineKeyboardButton("0", callback_data="pwd:0"),
            InlineKeyboardButton("👁" if masked else "🙈", callback_data="pwd:vis"),
        ]
    )
    rows.append([InlineKeyboardButton("确定", callback_data="pwd:ok")])
    return InlineKeyboardMarkup(rows)


async def start_set_password(update: Update, context: ContextTypes.DEFAULT_TYPE):
    u = update.effective_user
    context.user_data["pwd_buf"] = ""
    context.user_data["pwd_mask"] = True
    existed = await has_tx_password(u.id)
    title = "修改交易密码" if existed else "设置交易密码"
    hint = "请输入新交易密码（4~6位数字）"
    await update.message.reply_text(
        f"🛠 {title}\n{hint}\n\n🔑 " + "•" * 0, reply_markup=_kb(True)
    )


async def password_kb_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    data = (q.data or "").split(":")[1]
    buf = context.user_data.get("pwd_buf", "")
    masked = context.user_data.get("pwd_mask", True)

    if data == "back":
        await q.edit_message_text("已取消设置。")
        await show_main_menu(q.message.chat_id, context)
        return
    if data == "vis":
        masked = not masked
        context.user_data["pwd_mask"] = masked
        disp = "•" * len(buf) if masked else buf
        await q.edit_message_text(
            f"🛠 设置交易密码\n\n🔑 {disp}", reply_markup=_kb(masked)
        )
        return
    if data == "ok":
        if len(buf) < 4 or len(buf) > 6:
            await q.answer("请输入4~6位数字", show_alert=True)
            return
        u = q.from_user
        await set_tx_password_hash(u.id, hash_password(buf))
        await q.edit_message_text("✅ 交易密码设置成功")
        await show_main_menu(q.message.chat_id, context)
        return

    # 数据是数字
    if len(buf) >= 6:
        await q.answer("最多6位数字", show_alert=True)
        return
    buf += data
    context.user_data["pwd_buf"] = buf
    disp = "•" * len(buf) if masked else buf
    await q.edit_message_text(f"🛠 设置交易密码\n\n🔑 {disp}", reply_markup=_kb(masked))


=== src/handlers/recharge.py ===
from datetime import datetime, timedelta
from io import BytesIO

from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import ContextTypes

from ..config import MIN_DEPOSIT_USDT
from ..logger import recharge_logger
from ..models import (
    create_recharge_order,
    get_ledger_amount_by_ref,
    get_recharge_order,
    get_user_balance,
    get_wallet,
)
from ..services.qrcode_util import make_qr_png_bytes
from .common import fmt_amount, show_main_menu


def _fmt_code(s: str, tail: str = "👈 点击复制") -> str:
    # Telegram CODE 格式 + 两个空格 + 左指小手 + 点击复制
    return f"`{s}`  👈 {tail}"


async def show_recharge(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """点击【充值】——直接弹出二维码“图片查看器”+带说明的 caption。"""
    u = update.effective_user
    wallet = await get_wallet(u.id)
    addr = wallet.get("tron_address") if wallet else "-"

    # 若已有未过期订单，复用；否则生成新单（有效期 15 分钟）
    order_id = await create_recharge_order(u.id, addr, None, 15)

    # 二维码：缩小 50%，同时把地址写在图片下方（图上可见）
    caption_text = f"TRX/USDT-trc20 ONLY\n\n{addr}"
    png_bytes = make_qr_png_bytes(addr, scale=0.5, caption=caption_text)
    bio = BytesIO(png_bytes)
    bio.name = "recharge_qr.png"

    expire_at = (datetime.now() + timedelta(minutes=15)).strftime("%Y-%m-%d %H:%M:%S")
    human = (
        "⚠️ 充值金额 **{minu} USDT** 起；\n"
        "⏱ 订单到期：{exp}（剩余15分钟）；\n"
        "💡 充值后请耐心等待，到账会自动通知。"
    ).format(minu=fmt_amount(MIN_DEPOSIT_USDT), exp=expire_at)

    # 地址/订单号使用 CODE 样式；地址行末显示“👈 点击复制”
    cap = (
        f"🧾 **充值信息**\n"
        f"收款网络：USDT-TRC20\n\n"
        f"收款地址：{_fmt_code(addr)}\n"
        f"订单号：{_fmt_code(str(order_id))}\n\n"
        f"{human}"
    )

    kb = InlineKeyboardMarkup(
        [  # 按钮在文本下
            [
                InlineKeyboardButton(
                    "📋 复制地址", callback_data=f"recharge_copy:{order_id}"
                )
            ],
            [
                InlineKeyboardButton(
                    "🔄 刷新状态", callback_data=f"recharge_status:{order_id}"
                )
            ],
            [InlineKeyboardButton("⬅️ 返回主菜单", callback_data="back_to_menu")],
        ]
    )

    await update.message.reply_photo(
        photo=bio, caption=cap, reply_markup=kb, parse_mode="Markdown"
    )
    recharge_logger.info(f"🧾 用户 {u.id} 使用充值订单 {order_id}，地址 {addr}")


async def recharge_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    data = q.data or ""
    u = q.from_user

    if data == "back_to_menu":
        await q.message.reply_text("已返回主菜单。")
        await show_main_menu(q.message.chat_id, context)
        return

    if data.startswith("recharge_copy:"):
        wallet = await get_wallet(u.id)
        addr = wallet.get("tron_address") if wallet else "-"
        # 弹窗显示，用户可长按复制
        await q.answer(text=addr, show_alert=True)
        return

    if data.startswith("recharge_status:"):
        try:
            oid = int(data.split(":")[1])
        except Exception:
            await q.answer("订单号不合法", show_alert=True)
            return

        order = await get_recharge_order(oid)
        if not order:
            await q.answer("订单不存在或已过期", show_alert=True)
            return

        display = {
            "waiting": "等待用户转账",
            "collecting": "待归集",
            "verifying": "验证中",
            "success": "充值成功",
            "expired": "已过期",
            "failed": "失败",
        }
        st = order["status"]
        lines = [
            f"🧾 订单号：`{order['id']}`",
            f"状态：{display.get(st, st)}",
        ]
        if st == "success":
            # 查询本单充值到账金额（从账变里按 ref 找）
            amt = await get_ledger_amount_by_ref(
                user_id=order["user_id"],
                ref_type="recharge",
                ref_table="recharge_orders",
                ref_id=order["id"],
            )
            bal = await get_user_balance(order["user_id"])
            if amt is not None:
                lines.append(f"到账金额：**{fmt_amount(amt)} USDT**")
            lines.append(f"当前余额：**{fmt_amount(bal)} USDT**")
            lines.append("✅ 充值成功，祝您使用愉快！")

            await q.message.reply_markdown("\n".join(lines))
            # 结束后重现主菜单
            await show_main_menu(q.message.chat_id, context)
            return

        # 其他状态，仅展示文案
        await q.message.reply_markdown("\n".join(lines))
        # 给个返回主菜单
        await show_main_menu(q.message.chat_id, context)


=== src/handlers/red_packet.py ===
from decimal import Decimal

from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import ContextTypes

from ..handlers.common import ensure_user_and_wallet, fmt_amount
from ..keyboards import redpacket_create_menu
from ..models import (
    add_ledger,
    claim_share,
    count_claimed,
    create_red_packet,
    execute,
    get_red_packet,
    get_wallet,
    list_red_packet_shares,
    list_red_packets,
    save_red_packet_share,
    set_red_packet_status,
    update_wallet_balance,
)
from ..services.redalgo import split_average, split_random
from .common import show_main_menu

TYPES = [("random", "🎲 随机"), ("avg", "📦 平均"), ("exclusive", "🔒 专属")]


def _kb(cur: str):
    row = []
    for k, label in TYPES:
        prefix = "✅ " if k == cur else ""
        row.append(InlineKeyboardButton(prefix + label, callback_data=f"rp_type:{k}"))
    return InlineKeyboardMarkup([row])


def _render(cur: str) -> str:
    pretty = " | ".join([("👉" + l) if k == cur else l for k, l in TYPES])
    return (
        "🧧 发送红包\n\n"
        "封面未设置\n\n"
        "--- ☝️ 红包封面 ☝️ ---\n\n"
        f"类型：[ {pretty} ]\n\n"
        "币种：USDT-trc20\n数量：1\n金额：1.00\n\n"
        "提示：未领取的将在24小时后退款。"
    )


def _type_kb(cur: str):
    rows = []
    btns = []
    for k, label in TYPES:
        prefix = "✅ " if k == cur else ""
        btns.append(InlineKeyboardButton(prefix + label, callback_data=f"rp_type:{k}"))
    rows.append(btns)
    return InlineKeyboardMarkup(rows)


async def entry_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # ✅ 功能锁
    if await get_flag("lock_redpacket"):
        await update.message.reply_text("⚠️ 维护中..请稍候尝试!")
        await show_main_menu(update.effective_chat.id, context)
        return

    cur = context.user_data.get("rp_type", "random")
    context.user_data["rp_type"] = cur
    await update.message.reply_text(_render(cur), reply_markup=_kb(cur))


async def set_rp_type(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    try:
        _, t = (q.data or "rp_type:random").split(":", 1)
    except Exception:
        t = "random"
    if t not in [k for k, _ in TYPES]:
        t = "random"
    context.user_data["rp_type"] = t
    await q.edit_message_text(text=_render(t), reply_markup=_kb(t))


async def type_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    _, t = (q.data or "rp_type:random").split(":", 1)
    if t not in [k for k, _ in TYPES]:
        t = "random"
    context.user_data["rp_type"] = t
    cur = t
    text = (
        "🧧 发送红包\n\n"
        "封面未设置\n\n"
        "--- ☝️ 红包封面 ☝️ ---\n\n"
        f"类型：[{ '、'.join([('👉'+l) if k==cur else l for k,l in TYPES]) }]\n\n"
        "币种：USDT-trc20\n数量：1\n金额：1.00\n\n"
        "提示：未领取的将在24小时后退款。"
    )
    await q.edit_message_text(text=text, reply_markup=_type_kb(cur))


def _fmt_rp(r):
    return f"ID:{r['id']} | 类型:{r['type']} | 数量:{r['count']} | 总额:{fmt_amount(r['total_amount'])} | 状态:{r['status']}"


async def show_red_packets(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await ensure_user_and_wallet(update, context)
    u = update.effective_user
    recs = await list_red_packets(u.id, 10)
    lines = ["🧧 最近红包记录（最多10条）："]
    if recs:
        lines += [_fmt_rp(r) for r in recs]
    else:
        lines.append("（暂无）")
    kb = InlineKeyboardMarkup(
        [
            [InlineKeyboardButton("根据ID查看详情", callback_data="rp_query:ask")],
            [InlineKeyboardButton("➕ 创建红包", callback_data="rp_new")],
        ]
    )
    await update.message.reply_text("\n".join(lines), reply_markup=kb)


async def rp_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    data = q.data or ""
    u = update.effective_user

    if data == "rp_new":
        rp_id = await create_red_packet(u.id, "random", 1.0, 1, None, None, None)
        await q.message.reply_text(
            _compose_create_text("random", 1, 1.0, cover=None),
            reply_markup=redpacket_create_menu(rp_id, "random"),
        )
        return

    if data.startswith("rp_type:"):
        _, rp_id_str, new_type = data.split(":")
        rp_id = int(rp_id_str)
        await execute(
            "UPDATE red_packets SET type=%s, exclusive_user_id=IF(%s='exclusive',exclusive_user_id,NULL) WHERE id=%s",
            (new_type, new_type, rp_id),
        )
        r = await get_red_packet(rp_id)
        await q.message.reply_text(
            _compose_create_text(
                r["type"], r["count"], r["total_amount"], r.get("cover_text")
            ),
            reply_markup=redpacket_create_menu(rp_id, r["type"]),
        )
        return

    if data.startswith("rp_query:ask"):
        context.user_data["rp_query_waiting"] = True
        await q.message.reply_text("请输入红包ID：")
        return

    if data.startswith("rp_detail:"):
        rp_id = int(data.split(":")[1])
        r = await get_red_packet(rp_id)
        if not r:
            await q.message.reply_text("未找到红包。")
            return
        shares = await list_red_packet_shares(rp_id)
        claimed = sum(1 for s in shares if s["claimed_by"]) if shares else 0
        await q.message.reply_text(
            f"🧧 红包详情\nID:{r['id']}\n类型:{r['type']}\n币种:{r['currency']}\n数量:{r['count']}\n金额:{fmt_amount(r['total_amount'])}\n封面:{r.get('cover_text') or '未设置'}\n专属:{r.get('exclusive_user_id') or '无'}\n状态:{r['status']}\n已领:{claimed}/{r['count']}"
        )
        return

    if data.startswith("rp_set_count:"):
        rp_id = int(data.split(":")[1])
        context.user_data["await_field"] = ("count", rp_id)
        await q.message.reply_text("请输入红包数量（整数）：")
        return

    if data.startswith("rp_set_amount:"):
        rp_id = int(data.split(":")[1])
        context.user_data["await_field"] = ("amount", rp_id)
        await q.message.reply_text("请输入红包总金额（USDT，支持小数）：")
        return

    if data.startswith("rp_set_exclusive:"):
        rp_id = int(data.split(":")[1])
        context.user_data["await_field"] = ("exclusive", rp_id)
        await q.message.reply_text(
            "🧧 发送红包\n\n👩‍💻 确认专属红包领取人!\n请使用以下任意一种方式选择目标:\nA、 转发对方任意一条文字消息到这里来.\nB、 发送对方的账户ID，如：588726829\nC、 发送对方的用户名，如：@username"
        )
        return

    if data.startswith("rp_set_cover:"):
        rp_id = int(data.split(":")[1])
        context.user_data["await_field"] = ("cover", rp_id)
        await q.message.reply_text(
            "✍️ 设置封面\n👩‍💻 请发送一段文字（≤150字符）或图片作为红包的封面。"
        )
        return

    if data.startswith("rp_pay:"):
        rp_id = int(data.split(":")[1])
        r = await get_red_packet(rp_id)
        if not r:
            await q.message.reply_text("未找到红包。")
            return
        if r["type"] == "exclusive" and not r.get("exclusive_user_id"):
            await q.message.reply_text("专属红包必须设置专属对象，无法支付！")
            return

        wallet = await get_wallet(u.id)
        bal = Decimal(str(wallet["usdt_trc20_balance"])) if wallet else Decimal("0")
        total = Decimal(str(r["total_amount"]))
        if bal < total:
            await q.message.reply_text("余额不足，无法支付！请先充值。")
            return

        new_bal = bal - total
        await update_wallet_balance(u.id, float(new_bal))
        await add_ledger(
            u.id,
            "redpacket_send",
            -float(total),
            float(bal),
            float(new_bal),
            "red_packets",
            rp_id,
            "发送红包扣款",
        )

        if r["type"] == "random":
            shares = split_random(float(total), int(r["count"]))
        else:
            shares = split_average(float(total), int(r["count"]))
        for i, s in enumerate(shares, 1):
            await save_red_packet_share(rp_id, i, float(s))

        await set_red_packet_status(rp_id, "paid")

        cover = r.get("cover_text") or "封面未设置"
        type_cn = (
            "随机"
            if r["type"] == "random"
            else ("平均" if r["type"] == "average" else "专属")
        )
        await q.message.reply_text(
            f"🧧 发送红包\n\n{cover}\n\n--- ☝️ 红包封面 ☝️ ---\n\n类型：[{type_cn}]（下方可切换）\n币种：USDT-trc20\n数量：{r['count']}\n金额：{fmt_amount(r['total_amount'])}\n\n提示：未领取的将在24小时后退款。",
            reply_markup=InlineKeyboardMarkup(
                [
                    [
                        InlineKeyboardButton(
                            "🧧 立即领取", callback_data=f"rp_claim:{rp_id}"
                        )
                    ],
                    [
                        InlineKeyboardButton(
                            "查看详情", callback_data=f"rp_detail:{rp_id}"
                        )
                    ],
                ]
            ),
        )
        await set_red_packet_status(rp_id, "sent")
        return

    if data.startswith("rp_claim:"):
        rp_id = int(data.split(":")[1])
        r = await get_red_packet(rp_id)
        if not r or r["status"] not in ("sent", "paid"):
            await q.message.reply_text("红包不可领取或不存在。")
            return
        if (
            r["type"] == "exclusive"
            and r.get("exclusive_user_id") != update.effective_user.id
        ):
            await q.message.reply_text("你不是我的宝贝,你不能领取!")
            return

        share = await claim_share(rp_id, update.effective_user.id)
        if not share:
            await q.message.reply_text("红包已领完。")
            return

        amt = Decimal(str(share["amount"]))
        wallet = await get_wallet(update.effective_user.id)
        before = Decimal(str(wallet["usdt_trc20_balance"])) if wallet else Decimal("0")
        after = before + amt
        await update_wallet_balance(update.effective_user.id, float(after))
        await add_ledger(
            update.effective_user.id,
            "redpacket_claim",
            float(amt),
            float(before),
            float(after),
            "red_packets",
            rp_id,
            "领取红包入账",
        )
        try:
            await context.bot.send_message(
                chat_id=update.effective_user.id,
                text=f"红包到账：+{fmt_amount(amt)} USDT-trc20，已入账余额。",
            )
        except Exception:
            pass
        await q.message.reply_text(f"领取成功，金额：{fmt_amount(amt)} USDT-trc20！")

        claimed = await count_claimed(rp_id)
        if claimed >= int(r["count"]):
            await set_red_packet_status(rp_id, "finished")
        return


async def on_user_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if "await_field" not in context.user_data:
        return
    field, rp_id = context.user_data.pop("await_field")
    text = update.message.text or ""

    r = await get_red_packet(rp_id)
    if not r:
        await update.message.reply_text("红包不存在。")
        return

    curr_type = r["type"]
    curr_count = r["count"]
    curr_amount = r["total_amount"]
    cover = r.get("cover_text") or "未设置"

    if field == "count":
        try:
            n = int(text.strip())
            if n <= 0 or n > 1000:
                raise ValueError
            await execute("UPDATE red_packets SET count=%s WHERE id=%s", (n, rp_id))
            curr_count = n
        except Exception:
            await update.message.reply_text("数量无效，请输入正整数（≤1000）。")
            return

    elif field == "amount":
        try:
            v = float(text.strip())
            if v <= 0:
                raise ValueError
            await execute(
                "UPDATE red_packets SET total_amount=%s WHERE id=%s", (v, rp_id)
            )
            curr_amount = v
        except Exception:
            await update.message.reply_text("金额无效，请输入正数。")
            return

    elif field == "exclusive":
        target_id = None
        if update.message.forward_from:
            target_id = update.message.forward_from.id
        else:
            s = text.strip()
            if s.startswith("@"):
                await update.message.reply_text(
                    "已记录用户名（若无法解析 ID，请对方先私聊本机器人以建立映射）。"
                )
                await execute(
                    "UPDATE red_packets SET cover_text=CONCAT(COALESCE(cover_text,''),'（专属@', %s, '）') WHERE id=%s",
                    (s[1:], rp_id),
                )
            else:
                try:
                    target_id = int(s)
                except Exception:
                    target_id = None
        if target_id:
            await execute(
                "UPDATE red_packets SET exclusive_user_id=%s, type='exclusive' WHERE id=%s",
                (target_id, rp_id),
            )
            curr_type = "exclusive"

    elif field == "cover":
        if update.message.photo:
            file_id = update.message.photo[-1].file_id
            await execute(
                "UPDATE red_packets SET cover_image_file_id=%s WHERE id=%s",
                (file_id, rp_id),
            )
            cover = "[图片封面]"
        else:
            s = text.strip()
            if len(s) > 150:
                await update.message.reply_text("文字封面最多150字符，请重试。")
                return
            await execute(
                "UPDATE red_packets SET cover_text=%s WHERE id=%s", (s, rp_id)
            )
            cover = s or "未设置"

    await update.message.reply_text(
        _compose_create_text(
            curr_type,
            curr_count,
            curr_amount,
            cover=cover if cover != "未设置" else None,
        ),
        reply_markup=redpacket_create_menu(rp_id, curr_type),
    )


def _compose_create_text(rp_type: str, count: int, amount: float, cover=None) -> str:
    type_cn = {"random": "随机", "average": "平均", "exclusive": "专属"}.get(
        rp_type, "随机"
    )
    cover_line = cover if cover else "封面未设置"
    return (
        f"🧧 发送红包\n\n{cover_line}\n\n--- ☝️ 红包封面 ☝️ ---\n\n"
        f"类型：[{type_cn}]（下方可切换：随机｜平均｜专属）\n"
        f"币种：USDT-trc20\n数量：{count}\n金额：{fmt_amount(amount)}\n\n"
        "提示：未领取的将在24小时后退款。"
    )


=== src/handlers/start.py ===
from telegram import Update
from telegram.ext import ContextTypes

from ..handlers.common import ensure_user_and_wallet
from ..keyboards import MAIN_MENU

WELCOME = (
    "🎉 欢迎使用 *USDT-TRC20 红包机器人* ！\n\n"
    "我可以帮你：\n"
    "• 查看钱包余额、充值/提现、账变明细\n"
    "• 发送红包（随机｜平均｜专属），群内一键领取\n"
    "• 绑定常用地址，快捷提现\n"
    "• 汇率查询 & 地址有效性校验\n"
    "• 设置/修改交易密码\n\n"
    "👇 请选择下方菜单开始体验。"
)


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await ensure_user_and_wallet(update, context)
    await update.message.reply_text(
        WELCOME, reply_markup=MAIN_MENU, parse_mode="Markdown"
    )


=== src/handlers/support.py ===
from telegram import Update
from telegram.ext import ContextTypes

from ..config import SUPPORT_CONTACT


async def show_support(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(f"联系客服：{SUPPORT_CONTACT}")


=== src/handlers/wallet.py ===
# src/handlers/wallet.py
from telegram import Update
from telegram.ext import ContextTypes

from ..models import get_or_create_user, get_user_balance
from .common import fmt_amount, show_main_menu


async def my_wallet(update: Update, context: ContextTypes.DEFAULT_TYPE):
    u = update.effective_user
    user = await get_or_create_user(u.id, u.username or "")
    bal = await get_user_balance(user["id"])
    text = (
        f"👤 账户ID：{user['tg_id']}\n\n"
        f"💰 账户余额：\n"
        f"• USDT-TRC20：{fmt_amount(bal)}"
    )
    await update.message.reply_text(text)
    await show_main_menu(update.effective_chat.id, context)


async def help_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    txt = (
        "欢迎使用 USDT-TRC20 红包机器人：\n"
        "• 我的钱包：余额/资金明细\n"
        "• 充值：生成订单，扫码或复制地址\n"
        "• 提现：绑定常用地址后申请\n"
        "• 红包：随机/平均/专属 类型发送\n"
        "• 设置密码：九宫格输入，资金操作二次校验"
    )
    await update.message.reply_text(txt)
    await show_main_menu(update.effective_chat.id, context)


=== src/handlers/withdraw.py ===
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import ContextTypes

from ..config import MIN_WITHDRAW_USDT, WITHDRAW_FEE_FIXED
from ..logger import withdraw_logger
from ..models import get_flag, get_wallet, list_user_addresses
from .common import fmt_amount, show_main_menu


async def withdraw_entry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # ✅ 功能锁拦截必须写在异步函数内部
    if await get_flag("lock_withdraw"):
        await update.message.reply_text("⚠️ 维护中..请稍候尝试!")
        await show_main_menu(update.effective_chat.id, context)
        return

    # TODO: 这里继续你的提现流程（余额、地址列表、手续费说明等）
    await update.message.reply_text("提现功能开发中…")
    await show_main_menu(update.effective_chat.id, context)


async def show_withdraw(update: Update, context: ContextTypes.DEFAULT_TYPE):
    u = update.effective_user
    wallet = await get_wallet(u.id)
    bal = wallet["usdt_trc20_balance"] if wallet else 0.0
    text = (
        f"账户ID：\n{u.id}\n\nUSDT-trc20 -- 当前余额: {fmt_amount(bal)} U\n"
        f"提示: 最小提款金额: {fmt_amount(MIN_WITHDRAW_USDT)} U\n手续费: 0% + {fmt_amount(WITHDRAW_FEE_FIXED)} U\n"
    )
    if float(bal) < MIN_WITHDRAW_USDT + WITHDRAW_FEE_FIXED:
        text += "\n余额不足提现最低要求!"
        await update.message.reply_text(text)
        return

    addrs = await list_user_addresses(u.id)
    if not addrs:
        kb = InlineKeyboardMarkup(
            [[InlineKeyboardButton("添加地址", callback_data="addr_add_start")]]
        )
        await update.message.reply_text(
            text + "\n无常用钱包地址,请添加绑定:", reply_markup=kb
        )
        return

    lines = [text, "\n已添加常用地址："]
    btns = []
    for a in addrs:
        lines.append(f"- {a['alias']}  {a['address']}")
        btns.append(
            [
                InlineKeyboardButton(
                    f"提到 {a['alias']}", callback_data=f"withdraw_to:{a['id']}"
                )
            ]
        )
    await update.message.reply_text(
        "\n".join(lines), reply_markup=InlineKeyboardMarkup(btns)
    )


async def withdraw_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    data = q.data or ""
    if data.startswith("withdraw_to:"):
        await q.message.reply_text(
            "提现功能占位：将进行交易密码校验与链上转账，后续完善。"
        )
        withdraw_logger.info(f"📤 提现占位：事件 {data}")


=== src/keyboards.py ===
from telegram import (
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    KeyboardButton,
    ReplyKeyboardMarkup,
)

MAIN_MENU = ReplyKeyboardMarkup(
    [
        [KeyboardButton("💰 我的钱包")],
        [KeyboardButton("💱 汇率查询"), KeyboardButton("🧭 地址查询")],
        [KeyboardButton("🆘 联系客服"), KeyboardButton("🔐 设置密码/修改密码")],
    ],
    resize_keyboard=True,
)

WALLET_MENU = ReplyKeyboardMarkup(
    [
        [KeyboardButton("🧧 红包"), KeyboardButton("➕ 充值")],
        [KeyboardButton("💸 提现"), KeyboardButton("📒 资金明细")],
        [KeyboardButton("📎 常用地址")],
        [KeyboardButton("⬅️ 返回主菜单")],
    ],
    resize_keyboard=True,
)


def redpacket_inline_menu(rp_id: int):
    return InlineKeyboardMarkup(
        [
            [InlineKeyboardButton("🧧 立即领取", callback_data=f"rp_claim:{rp_id}")],
            [InlineKeyboardButton("查看详情", callback_data=f"rp_detail:{rp_id}")],
        ]
    )


def _type_row(rp_id: int, rp_type: str):
    def _btn(t, label):
        hand = "👉 " if t == rp_type else ""
        return InlineKeyboardButton(
            f"{hand}{label}", callback_data=f"rp_type:{rp_id}:{t}"
        )

    return [
        _btn("random", "随机"),
        _btn("average", "平均"),
        _btn("exclusive", "专属"),
    ]


def redpacket_create_menu(rp_id: int, rp_type: str):
    if rp_type in ("random", "average"):
        row1 = [
            InlineKeyboardButton("设置红包数量", callback_data=f"rp_set_count:{rp_id}"),
            InlineKeyboardButton(
                "设置红包金额", callback_data=f"rp_set_amount:{rp_id}"
            ),
        ]
    else:  # exclusive
        row1 = [
            InlineKeyboardButton(
                "设置专属对象", callback_data=f"rp_set_exclusive:{rp_id}"
            ),
            InlineKeyboardButton(
                "设置红包金额", callback_data=f"rp_set_amount:{rp_id}"
            ),
        ]
    row2 = [
        InlineKeyboardButton("设置封面", callback_data=f"rp_set_cover:{rp_id}"),
        InlineKeyboardButton("确认支付", callback_data=f"rp_pay:{rp_id}"),
    ]
    return InlineKeyboardMarkup([_type_row(rp_id, rp_type), row1, row2])


=== src/logger.py ===
import logging
import os
from logging.handlers import RotatingFileHandler

LOG_DIR = os.path.join(os.getcwd(), "logs")
os.makedirs(LOG_DIR, exist_ok=True)


def _make_handler(filename: str) -> RotatingFileHandler:
    handler = RotatingFileHandler(
        os.path.join(LOG_DIR, filename),
        maxBytes=5 * 1024 * 1024,
        backupCount=5,
        encoding="utf-8",
    )
    fmt = logging.Formatter("%(asctime)s [%(levelname)s] %(name)s: %(message)s")
    handler.setFormatter(fmt)
    return handler


def get_logger(name: str) -> logging.Logger:
    logger = logging.getLogger(name)
    if not logger.handlers:
        logger.setLevel(logging.INFO)
        sh = logging.StreamHandler()
        sh.setFormatter(
            logging.Formatter("%(asctime)s [%(levelname)s] %(name)s: %(message)s")
        )
        logger.addHandler(sh)
        mapping = {
            "recharge": "recharge.log",
            "redpacket": "redpacket.log",
            "user_click": "user_click.log",
            "withdraw": "withdraw.log",
            "password": "password.log",
            "address": "address.log",
            "collect": "collect.log",
        }
        filename = mapping.get(name, "app.log")
        logger.addHandler(_make_handler(filename))
    return logger


recharge_logger = get_logger("recharge")
redpacket_logger = get_logger("redpacket")
user_click_logger = get_logger("user_click")
withdraw_logger = get_logger("withdraw")
password_logger = get_logger("password")
address_logger = get_logger("address")
collect_logger = get_logger("collect")
app_logger = get_logger("app")


=== src/main.py ===
# src/main.py
from telegram import BotCommand
from telegram.ext import (
    ApplicationBuilder,
    CallbackQueryHandler,
    CommandHandler,
    MessageHandler,
    filters,
)

from .config import BOT_TOKEN
from .handlers import addr_query as h_addrq
from .handlers import password as h_pwd
from .handlers import recharge as h_recharge
from .handlers import red_packet as h_rp
from .handlers import wallet as h_wallet
from .handlers import withdraw as h_withdraw

# 仅处理私聊的 filter
PRIVATE = filters.ChatType.PRIVATE


async def on_startup(app):
    # 在 post_init 回调里设置菜单命令，避免模块顶层 await
    await app.bot.set_my_commands(
        [
            BotCommand("start", "开始使用"),
            BotCommand("wallet", "我的钱包"),
            BotCommand("recharge", "充值"),
            BotCommand("withdraw", "提现"),
            BotCommand("redpacket", "红包"),
            BotCommand("help", "帮助"),
        ]
    )


def build_app():
    app = ApplicationBuilder().token(BOT_TOKEN).post_init(on_startup).build()

    # 命令
    app.add_handler(CommandHandler(["start", "wallet"], h_wallet.my_wallet, PRIVATE))
    app.add_handler(CommandHandler("recharge", h_recharge.show_recharge, PRIVATE))
    app.add_handler(CommandHandler("withdraw", h_withdraw.withdraw_entry, PRIVATE))
    app.add_handler(CommandHandler("redpacket", h_rp.entry_menu, PRIVATE))
    app.add_handler(CommandHandler("set_password", h_pwd.start_set_password, PRIVATE))
    app.add_handler(CommandHandler("help", h_wallet.help_text, PRIVATE))

    # 回调按钮
    app.add_handler(
        CallbackQueryHandler(
            h_recharge.recharge_callback,
            PRIVATE & filters.regex(r"^(recharge_|back_to_menu)"),
        )
    )
    app.add_handler(
        CallbackQueryHandler(h_rp.type_callback, PRIVATE & filters.regex(r"^rp_type:"))
    )
    app.add_handler(
        CallbackQueryHandler(
            h_pwd.password_kb_callback,
            PRIVATE & filters.regex(r"^pwd:(?:\d|ok|back|vis)$"),
        )
    )

    # 地址查询：用户输入地址文本
    app.add_handler(
        MessageHandler(PRIVATE & filters.TEXT & ~filters.COMMAND, h_addrq.on_text)
    )

    return app


def main():
    app = build_app()
    app.run_polling(close_loop=False)


if __name__ == "__main__":
    main()


=== src/models.py ===
import random
import string
from datetime import datetime
from typing import Any, Dict, List, Optional

from .db import execute, fetchall, fetchone  # 导出 execute 供其他模块使用

# =========================
# 小工具
# =========================


def _rand_letters(n: int = 4) -> str:
    return "".join(random.choice(string.ascii_lowercase) for _ in range(n))


# ---------- 用户 ----------
async def get_or_create_user(tg_id: int, username: str) -> Dict[str, Any]:
    row = await fetchone(
        "SELECT id, tg_id, username FROM users WHERE tg_id=%s", (tg_id,)
    )
    if not row:
        await execute(
            "INSERT INTO users(tg_id, username, usdt_trc20) VALUES(%s,%s,0)",
            (tg_id, (username or "")[:64]),
        )
        row = await fetchone(
            "SELECT id, tg_id, username FROM users WHERE tg_id=%s", (tg_id,)
        )
    return row


async def get_user_balance(user_id: int) -> float:
    row = await fetchone("SELECT usdt_trc20 FROM users WHERE id=%s", (user_id,))
    return float(row["usdt_trc20"] or 0) if row else 0.0


async def set_user_balance(user_id: int, new_balance: float) -> None:
    await execute("UPDATE users SET usdt_trc20=%s WHERE id=%s", (new_balance, user_id))


# =========================
# 充值订单（recharge_orders）
# =========================
async def get_recharge_orders_by_status(status_list: List[str]) -> List[Dict[str, Any]]:
    if not status_list:
        return []
    ph = ",".join(["%s"] * len(status_list))
    sql = f"SELECT * FROM recharge_orders WHERE status IN ({ph}) ORDER BY id ASC"
    return await fetchall(sql, tuple(status_list))


def make_order_no(dt: Optional[datetime] = None) -> str:
    """
    订单号规则：YYYYMMDDHHMM + 4位小写字母，如 202510151945abcd
    """
    dt = dt or datetime.now()
    return dt.strftime("%Y%m%d%H%M") + _rand_letters(4)


async def get_active_recharge_order(user_id: int) -> Optional[Dict[str, Any]]:
    return await fetchone(
        "SELECT * FROM recharge_orders "
        "WHERE user_id=%s AND status='waiting' AND expire_at>NOW() "
        "ORDER BY id DESC LIMIT 1",
        (user_id,),
    )


async def create_recharge_order(
    user_id: int, address: str, expected_amount: Optional[float], expire_minutes: int
) -> int:
    order_no = make_order_no()
    sql = (
        "INSERT INTO recharge_orders(order_no, user_id, address, expected_amount, status, created_at, expire_at) "
        "VALUES(%s,%s,%s,%s,'waiting',NOW(), DATE_ADD(NOW(), INTERVAL %s MINUTE))"
    )
    new_id = await execute(
        sql, (order_no, user_id, address, expected_amount, expire_minutes)
    )
    return new_id


async def get_recharge_order(order_id: int) -> Optional[Dict[str, Any]]:
    return await fetchone("SELECT * FROM recharge_orders WHERE id=%s", (order_id,))


async def list_recharge_waiting() -> List[Dict[str, Any]]:
    return await fetchall(
        "SELECT * FROM recharge_orders WHERE status='waiting' AND expire_at>NOW() ORDER BY id ASC LIMIT 100",
        (),
    )


async def list_recharge_collecting() -> List[Dict[str, Any]]:
    return await fetchall(
        "SELECT * FROM recharge_orders WHERE status='collecting' ORDER BY id ASC LIMIT 100",
        (),
    )


async def list_recharge_verifying() -> List[Dict[str, Any]]:
    return await fetchall(
        "SELECT * FROM recharge_orders WHERE status='verifying' ORDER BY id ASC LIMIT 100",
        (),
    )


async def set_recharge_status(order_id: int, status: str, txid: Optional[str]) -> None:
    if txid:
        await execute(
            "UPDATE recharge_orders SET status=%s, txid=%s, updated_at=NOW() WHERE id=%s",
            (status, txid, order_id),
        )
    else:
        await execute(
            "UPDATE recharge_orders SET status=%s, updated_at=NOW() WHERE id=%s",
            (status, order_id),
        )


async def ledger_exists_for_ref(ref_type: str, ref_table: str, ref_id: int) -> bool:
    row = await fetchone(
        "SELECT id FROM ledger WHERE ref_type=%s AND ref_table=%s AND ref_id=%s LIMIT 1",
        (ref_type, ref_table, ref_id),
    )
    return bool(row)


# =========================
# 用户 / 交易密码（users）
# =========================


async def ensure_user(
    user_id: int,
    username: Optional[str],
    first_name: Optional[str],
    last_name: Optional[str],
):
    await execute(
        "INSERT IGNORE INTO users(id, username, first_name, last_name, created_at) "
        "VALUES(%s,%s,%s,%s,NOW())",
        (user_id, username, first_name, last_name),
    )


async def get_user(user_id: int) -> Optional[Dict[str, Any]]:
    return await fetchone("SELECT * FROM users WHERE id=%s", (user_id,))


async def get_tx_password_hash(user_id: int) -> Optional[str]:
    row = await fetchone("SELECT tx_password_hash FROM users WHERE id=%s", (user_id,))
    return row.get("tx_password_hash") if row else None


async def has_tx_password(tg_id: int) -> bool:
    row = await fetchone("SELECT tx_password_hash FROM users WHERE tg_id=%s", (tg_id,))
    return bool(row and row.get("tx_password_hash"))


async def set_tx_password_hash(tg_id: int, h: str) -> None:
    await execute("UPDATE users SET tx_password_hash=%s WHERE tg_id=%s", (h, tg_id))


# =========================
# 钱包（user_wallets）
# =========================


async def get_wallet(user_id: int) -> Optional[Dict[str, Any]]:
    return await fetchone("SELECT * FROM user_wallets WHERE user_id=%s", (user_id,))


async def set_tron_wallet(user_id: int, address: str, privkey_enc: str):
    await execute(
        "INSERT INTO user_wallets(user_id, tron_address, tron_privkey_enc, usdt_trc20_balance) "
        "VALUES(%s,%s,%s,0) "
        "ON DUPLICATE KEY UPDATE tron_address=VALUES(tron_address), tron_privkey_enc=VALUES(tron_privkey_enc)",
        (user_id, address, privkey_enc),
    )


async def update_wallet_balance(user_id: int, new_bal: float):
    await execute(
        "UPDATE user_wallets SET usdt_trc20_balance=%s WHERE user_id=%s",
        (new_bal, user_id),
    )


# =========================
# 账变（ledger）
# =========================


async def add_ledger(
    user_id: int,
    change_type: str,  # 'recharge' | 'withdraw' | 'redpacket_send' | 'redpacket_claim' | 'adjust'
    amount: float,
    balance_before: float,
    balance_after: float,
    ref_table: Optional[str] = None,
    ref_type: Optional[str] = None,
    ref_id: Optional[int] = None,
    remark: Optional[str] = None,
) -> None:
    await execute(
        "INSERT INTO ledger(user_id, change_type, ref_table, amount, balance_before, balance_after, "
        "ref_type, ref_id, remark, created_at) "
        "VALUES(%s,%s,%s,%s,%s,%s,%s,%s,%s,NOW())",
        (
            user_id,
            change_type,
            ref_table,
            amount,
            balance_before,
            balance_after,
            ref_type,
            ref_id,
            (remark or "")[:255],
        ),
    )


async def list_ledger_recent(user_id: int, limit: int = 10) -> List[Dict[str, Any]]:
    return await fetchall(
        "SELECT * FROM ledger WHERE user_id=%s ORDER BY id DESC LIMIT %s",
        (user_id, limit),
    )


# =========================
# 地址簿（user_addresses）
# =========================


async def list_user_addresses(user_id: int) -> List[Dict[str, Any]]:
    return await fetchall(
        "SELECT * FROM user_addresses WHERE user_id=%s ORDER BY id DESC", (user_id,)
    )


async def add_user_address(user_id: int, address: str, alias: str) -> int:
    """
    新增常用地址；建议在上层校验别名长度<=15、TRON 地址格式等。
    表结构：user_addresses(id PK AI, user_id, address, alias, created_at)
    """
    return await execute(
        "INSERT INTO user_addresses(user_id, address, alias, created_at) VALUES(%s,%s,%s,NOW())",
        (user_id, address, alias),
    )


async def delete_user_address(addr_id: int, user_id: int) -> None:
    await execute(
        "DELETE FROM user_addresses WHERE id=%s AND user_id=%s", (addr_id, user_id)
    )


async def get_user_address_by_alias(
    user_id: int, alias: str
) -> Optional[Dict[str, Any]]:
    return await fetchone(
        "SELECT * FROM user_addresses WHERE user_id=%s AND alias=%s", (user_id, alias)
    )


# =========================
# 红包（red_packets, red_packet_shares）
# =========================


async def list_red_packets(user_id: int, limit: int = 10) -> List[Dict[str, Any]]:
    return await fetchall(
        "SELECT * FROM red_packets WHERE user_id=%s ORDER BY id DESC LIMIT %s",
        (user_id, limit),
    )


async def create_red_packet(
    user_id: int,
    rp_type: str,
    total_amount: float,
    count: int,
    currency: Optional[str],
    cover_text: Optional[str],
    exclusive_user_id: Optional[int],
) -> int:
    currency = currency or "USDT-trc20"
    sql = (
        "INSERT INTO red_packets(user_id, type, total_amount, count, currency, cover_text, exclusive_user_id, status, created_at) "
        "VALUES(%s,%s,%s,%s,%s,%s,%s,'draft',NOW())"
    )
    new_id = await execute(
        sql,
        (
            user_id,
            rp_type,
            total_amount,
            count,
            currency,
            cover_text,
            exclusive_user_id,
        ),
    )
    return new_id


async def get_red_packet(rp_id: int) -> Optional[Dict[str, Any]]:
    return await fetchone("SELECT * FROM red_packets WHERE id=%s", (rp_id,))


async def set_red_packet_status(rp_id: int, status: str):
    await execute(
        "UPDATE red_packets SET status=%s, updated_at=NOW() WHERE id=%s",
        (status, rp_id),
    )


async def save_red_packet_share(rp_id: int, seq: int, amount: float):
    await execute(
        "INSERT INTO red_packet_shares(red_packet_id, seq, amount) VALUES(%s,%s,%s)",
        (rp_id, seq, amount),
    )


async def list_red_packet_shares(rp_id: int) -> List[Dict[str, Any]]:
    return await fetchall(
        "SELECT * FROM red_packet_shares WHERE red_packet_id=%s ORDER BY id ASC",
        (rp_id,),
    )


async def claim_share(rp_id: int, user_id: int) -> Optional[Dict[str, Any]]:
    """
    简单两段式防并发：
    1) 抓一条未领取份额
    2) 抢占（claimed_by IS NULL）→ 然后再读取返回
    """
    row = await fetchone(
        "SELECT id FROM red_packet_shares WHERE red_packet_id=%s AND claimed_by IS NULL ORDER BY id ASC LIMIT 1",
        (rp_id,),
    )
    if not row:
        return None
    sid = row["id"]
    await execute(
        "UPDATE red_packet_shares SET claimed_by=%s, claimed_at=NOW() WHERE id=%s AND claimed_by IS NULL",
        (user_id, sid),
    )
    got = await fetchone("SELECT * FROM red_packet_shares WHERE id=%s", (sid,))
    if not got or got.get("claimed_by") != user_id:
        return None
    return got


async def count_claimed(rp_id: int) -> int:
    row = await fetchone(
        "SELECT COUNT(*) AS c FROM red_packet_shares WHERE red_packet_id=%s AND claimed_by IS NOT NULL",
        (rp_id,),
    )
    return int(row["c"] if row else 0)


# 兼容旧代码：有的地方引了 add_red_packet_claim，这里提供空实现避免 ImportError
async def add_red_packet_claim(*args, **kwargs):
    return 0


# —— 能量租用记录 —— #
async def last_energy_rent_seconds_ago(address: str) -> int:
    row = await fetchone(
        "SELECT TIMESTAMPDIFF(SECOND, rented_at, NOW()) AS sec FROM energy_rent_logs "
        "WHERE address=%s ORDER BY id DESC LIMIT 1",
        (address,),
    )
    if not row or row.get("sec") is None:
        return 10**9
    return int(row["sec"])


async def has_active_energy_rent(address: str) -> bool:
    row = await fetchone(
        "SELECT id FROM energy_rents WHERE address=%s AND expires_at > NOW() LIMIT 1",
        (address,),
    )
    return bool(row)


async def add_energy_rent_log(
    address: str,
    order_id: int,
    order_no: str,
    rent_order_id: Optional[str] = None,
    ttl_seconds: int = 3600,
) -> None:
    # FROM_UNIXTIME(UNIX_TIMESTAMP(NOW()) + %s) 兼容 5.7
    await execute(
        "INSERT INTO energy_rents(address, order_id, order_no, rent_order_id, expires_at, created_at) "
        "VALUES(%s,%s,%s,%s, FROM_UNIXTIME(UNIX_TIMESTAMP(NOW()) + %s), NOW())",
        (address, order_id, order_no, rent_order_id, int(ttl_seconds)),
    )


async def mark_energy_rent_used(address: str) -> None:
    await execute(
        "UPDATE energy_rent_logs SET status='used' WHERE address=%s AND status='active'",
        (address,),
    )


async def get_flag(key: str) -> bool:
    row = await fetchone("SELECT v FROM sys_flags WHERE k=%s", (key,))
    return str(row["v"]).strip() == "1" if row else False


async def set_flag(key: str, on: bool) -> None:
    v = "1" if on else "0"
    # MySQL 5.7 没有标准 UPSERT，用 ON DUPLICATE KEY
    await execute(
        "INSERT INTO sys_flags(k,v) VALUES(%s,%s) "
        "ON DUPLICATE KEY UPDATE v=VALUES(v), updated_at=NOW()",
        (key, v),
    )


async def sum_user_usdt_balance() -> float:
    row = await fetchone("SELECT COALESCE(SUM(usdt_trc20),0) AS s FROM users", ())
    return float(row["s"] or 0)


async def get_ledger_amount_by_ref(ref_type: str, ref_table: str, ref_id: int) -> float:
    row = await fetchone(
        "SELECT COALESCE(SUM(amount),0) AS s FROM ledger WHERE ref_type=%s AND ref_table=%s AND ref_id=%s",
        (ref_type, ref_table, ref_id),
    )
    return float(row["s"] or 0)


=== src/services/encryption.py ===
from cryptography.fernet import Fernet

from ..config import FERNET_KEY

_cipher = Fernet(FERNET_KEY.encode() if isinstance(FERNET_KEY, str) else FERNET_KEY)


def encrypt_text(s: str) -> str:
    return _cipher.encrypt(s.encode()).decode()


def decrypt_text(token: str) -> str:
    return _cipher.decrypt(token.encode()).decode()


=== src/services/energy.py ===
# src/services/energy.py
import os
import re
from typing import Any, Dict, Optional

import httpx

from ..config import TRONGAS_API_KEY
from ..logger import collect_logger

API_URL = "https://trongas.io/api/batchPay"


def _normalize_paynums(n: int) -> int:
    """
    将请求量 n 归一化到 >= 最小租用量，且按步长向上取整。
    TRONGAS_MIN_RENT 默认 32000，TRONGAS_RENT_STEP 默认 1000。
    """
    min_rent = int(os.getenv("TRONGAS_MIN_RENT", "32000"))
    step = max(int(os.getenv("TRONGAS_RENT_STEP", "1000")), 1)
    n = max(int(n), min_rent)
    n = ((n + step - 1) // step) * step
    return n


def _safe_notes(s: Optional[str]) -> str:
    """
    备注只允许：汉字 / 字母 / 数字 / 下划线 _ / 破折号 -
    并限制长度（<=32），防止触发 trongas 校验。
    """
    s = s or ""
    s = re.sub(r"[^0-9A-Za-z_\-\u4e00-\u9fff]", "", s)
    s = s[:32]
    return s or "hb"


async def rent_energy(
    receive_address: str,
    pay_nums: int = 65000,
    rent_time: int = 1,
    order_notes: Optional[str] = None,
) -> Dict[str, Any]:
    """
    调用 trongas 能量租用接口（仅使用 apiKey）。
    - 单次最小 32000，按步长取整（默认 1000）。
    - 备注字符合规。
    """
    if not TRONGAS_API_KEY:
        raise RuntimeError("TRONGAS_API_KEY 未配置，无法租用能量")

    pay_nums = _normalize_paynums(pay_nums)
    order_notes = _safe_notes(order_notes)

    payload = {
        "apiKey": TRONGAS_API_KEY,
        "payNums": int(pay_nums),
        "rentTime": int(rent_time),
        "receiveAddress": receive_address,
        "orderNotes": order_notes,
    }

    collect_logger.info(
        f"⚡ 正在请求租用能量：payNums={pay_nums}, rentTime={rent_time}, addr={receive_address}, notes='{order_notes}'"
    )

    async with httpx.AsyncClient(timeout=30) as client:
        r = await client.post(API_URL, json=payload)
        r.raise_for_status()
        data = r.json()
        # 统一错误抛出（保留服务端 code/msg）
        if data.get("code") != 10000:
            raise RuntimeError(
                f"trongas 下单失败：code={data.get('code')} msg={data.get('msg')}"
            )
        return data.get("data", {})


=== src/services/qrcode_util.py ===
# src/services/qrcode_util.py
import io
from typing import Optional

import qrcode
from PIL import Image, ImageDraw, ImageFont


def make_qr_png_bytes(
    data: str, scale: float = 0.5, caption: Optional[str] = None
) -> bytes:
    # 生成二维码
    qr = qrcode.QRCode(border=2, box_size=10)
    qr.add_data(data)
    qr.make(fit=True)
    img = qr.make_image(fill_color="black", back_color="white").convert("RGB")

    # 缩放
    if 0 < scale < 1.0:
        w, h = img.size
        img = img.resize((int(w * scale), int(h * scale)), Image.LANCZOS)

    # 叠加地址文字（自动换行）
    if caption:
        pad = 16
        W, H = img.size
        font = ImageFont.load_default()
        draw = ImageDraw.Draw(img)

        # 简单按宽度截断换行
        lines, cur, maxw = [], "", W - 20
        for ch in caption:
            trial = cur + ch
            if draw.textlength(trial, font=font) > maxw:
                lines.append(cur)
                cur = ch
            else:
                cur = trial
        if cur:
            lines.append(cur)

        line_h = 14
        text_h = line_h * len(lines) + pad
        canvas = Image.new("RGB", (W, H + text_h), "white")
        canvas.paste(img, (0, 0))
        draw = ImageDraw.Draw(canvas)
        y = H + (pad // 2)
        for ln in lines:
            draw.text((10, y), ln, fill="black", font=font)
            y += line_h
        img = canvas

    # 输出 PNG
    buf = io.BytesIO()
    img.save(buf, format="PNG")
    return buf.getvalue()


=== src/services/redalgo.py ===
import random
from decimal import Decimal, getcontext
from typing import List

# 使用 6 位小数，适配 USDT 常见精度
getcontext().prec = 28


def _d(x) -> Decimal:
    if isinstance(x, Decimal):
        return x
    return Decimal(str(x))


def split_random(total_amount: float, count: int) -> List[Decimal]:
    """
    随机红包：
    - 单份最大不超过 2 * (均值)
    - 总和严格等于 total_amount
    - 避免出现 0 或最后一份过大的情况
    """
    assert count >= 1
    total = _d(total_amount)
    mean = total / _d(count)
    max_per = mean * _d(2)  # 最大值限制
    shares = []
    remain = total

    for i in range(1, count + 1):
        remain_count = count - len(shares)
        if remain_count == 1:
            # 最后一份
            amt = remain
        else:
            # 剩余均值附近随机，限制上限与下限
            max_allowed = min(max_per, remain - _d("0.000001") * (remain_count - 1))
            min_allowed = max(_d("0.000001"), remain / _d(remain_count) / _d(2))
            if max_allowed < min_allowed:
                max_allowed = min_allowed
            # 在 [min_allowed, max_allowed] 间随机
            r = Decimal(str(random.random()))
            amt = min_allowed + r * (max_allowed - min_allowed)
            # 四舍五入到 6 位小数
            amt = amt.quantize(Decimal("0.000001"))
            if amt <= _d("0"):
                amt = _d("0.000001")
        remain -= amt
        remain = remain.quantize(Decimal("0.000001"))
        shares.append(amt)

    # 修正总和误差
    diff = total - sum(shares)
    if diff != 0:
        shares[-1] = (shares[-1] + diff).quantize(Decimal("0.000001"))
        if shares[-1] <= 0:
            # 极端回退，重新平摊
            return split_average(total_amount, count)

    return shares


def split_average(total_amount: float, count: int) -> List[Decimal]:
    total = _d(total_amount)
    base = (total / _d(count)).quantize(Decimal("0.000001"))
    shares = [base for _ in range(count)]
    # 调整小数误差
    diff = total - sum(shares)
    shares[-1] = (shares[-1] + diff).quantize(Decimal("0.000001"))
    return shares


=== src/services/tron.py ===
import asyncio
import os
import random
import re
import time
from dataclasses import dataclass
from decimal import Decimal
from typing import Dict, List, Optional, Union
from decimal import Decimal as _Decimal
from typing import Optional as _Optional

import requests
from tronpy import Tron
from tronpy.exceptions import TransactionNotFound
from tronpy.keys import PrivateKey
from tronpy.providers import HTTPProvider

from ..config import (
    TRON_FULLNODE_URL,
    TRONGRID_API_KEY,
    TRONGRID_QPS,
    USDT_CONTRACT,
    USDT_DECIMALS,
)
from ..logger import collect_logger

TRON_GRID_KEYS = [
    k.strip() for k in os.getenv("TRONGRID_API_KEY", "").split(",") if k.strip()
]

async def get_trc20_balance(address: str, contract_address: str) -> _Decimal:
    """
    查询任意 TRC-20 合约余额；返回 Decimal 金额，按合约 decimals 处理。
    与已有代码兼容：await get_trc20_balance(addr, USDT_CONTRACT)
    """
    import asyncio

    def _task() -> _Decimal:
        # 依赖现有 tron.py 的 _get_client()，不要改动你的连接/限流策略
        c = _get_client()  # 若你的 tron 客户端构造函数名不同，请改成你自己的
        ctr = c.get_contract(contract_address)
        raw = ctr.functions.balanceOf(address)  # int
        try:
            decimals = int(ctr.functions.decimals())
        except Exception:
            decimals = 6  # USDT 默认为 6；取不到就保守按 6
        return _Decimal(raw) / (_Decimal(10) ** decimals)

    loop = asyncio.get_running_loop()
    return await loop.run_in_executor(None, _task)



def _tg_headers(ix: int):
    h = {"Accept": "application/json"}
    if TRON_GRID_KEYS:
        h["TRON-PRO-API-KEY"] = TRON_GRID_KEYS[ix % len(TRON_GRID_KEYS)]
    return h


def _tg_get(url, params=None, tries=3, backoff=0.7):
    for i in range(tries):
        r = requests.get(url, params=params or {}, headers=_tg_headers(i), timeout=15)
        if r.status_code == 429:
            time.sleep(backoff * (i + 1))
            continue
        r.raise_for_status()
        return r.json()
    raise RuntimeError("TronGrid 429/失败过多")


async def get_recent_transfers(address: str, limit: int = 10) -> List[Dict]:
    url = f"https://api.trongrid.io/v1/accounts/{address}/transactions/trc20"
    js = _tg_get(url, params={"limit": limit})
    out = []
    for it in js.get("data", []):
        v = it.get("value", {})
        if not v:
            continue
        out.append(
            {
                "hash": it.get("transaction_id", ""),
                "from": v.get("from", ""),
                "to": v.get("to", ""),
                "amount": float(v.get("value", 0)) / (10 ** int(v.get("decimal", 6))),
                "asset": v.get("symbol", "USDT"),
            }
        )
    return out


def get_trx_balance(address: str) -> float:
    """
    读取地址TRX余额（单位：TRX）
    """
    c = _get_client()
    acc = c.get_account(address)  # dict；balance 为 Sun
    bal_sun = int(acc.get("balance", 0))
    return bal_sun / 1_000_000.0


def wait_tx_committed(txid: str, timeout: int = 45, interval: float = 1.5) -> dict:
    """
    轮询查询交易信息，直到返回结果或超时。
    返回 info 字典；若 info.get('result') == 'FAILED' 则视为失败。
    """
    c = _get_client()
    deadline = time.time() + timeout
    last_err = None
    while time.time() < deadline:
        try:
            info = c.get_transaction_info(txid)
            # TRX 普通转账可能没有 contractRet；出现 'result': 'SUCCESS' 或包含 blockNumber 即可视为成功
            if info and (
                info.get("result") == "SUCCESS" or info.get("blockNumber") is not None
            ):
                return info
            # 有明确失败
            if info and info.get("result") == "FAILED":
                return info
        except TransactionNotFound as e:
            last_err = e
        time.sleep(interval)
    # 超时也返回最后一次获取到的 info 或抛出
    if last_err:
        raise last_err
    return {}


@dataclass
class TronAddress:
    address: str
    private_key_hex: str  # 64 hex


# ========== 基础工具：全局异步限速 ==========
class AsyncRateLimiter:
    """简单的最小间隔限速器，按 QPS 计算调用间隔"""

    def __init__(self, qps: float):
        self.interval = 1.0 / max(qps, 0.1)
        self._last = 0.0
        self._lock = asyncio.Lock()

    async def wait(self):
        async with self._lock:
            now = time.monotonic()
            wait_for = self.interval - (now - self._last)
            if wait_for > 0:
                await asyncio.sleep(wait_for)
            self._last = time.monotonic()


_limiter = AsyncRateLimiter(TRONGRID_QPS)


def _parse_keys(raw: str) -> Optional[Union[str, List[str]]]:
    if not raw:
        return None
    ks = [k.strip() for k in raw.split(",") if k.strip()]
    if not ks:
        return None
    return ks if len(ks) > 1 else ks[0]


def _get_client() -> Tron:
    """创建 Tron 客户端；带 TronGrid API Key（支持多个 Key 轮换）"""
    api_keys = _parse_keys(TRONGRID_API_KEY)
    provider = HTTPProvider(
        endpoint_uri=TRON_FULLNODE_URL or "https://api.trongrid.io",
        api_key=api_keys,
        timeout=20.0,
    )
    return Tron(provider)


def get_account_resource(address: str) -> dict:
    """
    返回 {'bandwidth': int, 'energy': int}
    带宽 = (freeNetLimit - freeNetUsed) + (NetLimit - NetUsed)
    能量 = (EnergyLimit - EnergyUsed)
    """
    c = _get_client()
    info = c.get_account_resource(address)
    bw = max(
        0, int(info.get("freeNetLimit", 0)) - int(info.get("freeNetUsed", 0))
    ) + max(0, int(info.get("NetLimit", 0)) - int(info.get("NetUsed", 0)))
    en = max(0, int(info.get("EnergyLimit", 0)) - int(info.get("EnergyUsed", 0)))
    return {"bandwidth": bw, "energy": en}


def send_trx(priv_hex: str, from_addr: str, to_addr: str, amount_trx: float) -> str:
    c = _get_client()
    amt_sun = int(Decimal(str(amount_trx)) * Decimal(1_000_000))
    tx = (
        c.trx.transfer(from_addr, to_addr, amt_sun)
        .build()
        .sign(PrivateKey(bytes.fromhex(priv_hex)))
        .broadcast()
    )
    txid = tx.txid
    info = wait_tx_committed(txid, timeout=45)
    # 判定成功：有块号且未标记 FAILED
    if info and info.get("result") != "FAILED" and info.get("blockNumber") is not None:
        return txid
    raise RuntimeError(f"TRX topup not confirmed: {info or 'no-info'} txid={txid}")


def generate_address() -> TronAddress:
    """仅用于占位/初始化，生产上请使用你现有的加密私钥方案"""
    pk = PrivateKey.random()
    return TronAddress(
        address=pk.public_key.to_base58check_address(),
        private_key_hex=pk.hex(),
    )


async def _retry_with_backoff(coro_func, *args, **kwargs):
    """
    指数退避重试：处理 401/403/429 或 requests.HTTPError
    回退：1s / 2s / 4s / 8s（叠加轻微抖动）
    """
    for attempt in range(4):
        try:
            return await coro_func(*args, **kwargs)
        except Exception as e:
            code = getattr(getattr(e, "response", None), "status_code", None)
            if code in (401, 403, 429) or isinstance(e, requests.HTTPError):
                delay = (2**attempt) + random.uniform(0, 0.5)
                collect_logger.warning(
                    f"[TronGrid] 受限/未授权，重试 {attempt+1}/4，{delay:.2f}s 后重试；err={e}"
                )
                await asyncio.sleep(delay)
                continue
            raise


async def get_usdt_balance(address: str) -> float:
    async def _call():
        await _limiter.wait()

        def _task():
            c = _get_client()
            usdt = c.get_contract(USDT_CONTRACT)
            raw = usdt.functions.balanceOf(address)
            return float(Decimal(raw) / (Decimal(10) ** USDT_DECIMALS))

        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(None, _task)

    return await _retry_with_backoff(_call)


async def usdt_transfer_all(
    priv_hex: str, from_addr: str, to_addr: str, amount: float
) -> str:
    """
    将 amount USDT 从 from_addr 转到 to_addr，等待确认，返回 txid
    如果回执不是 SUCCESS（如 OUT_OF_ENERGY / REVERT 等），直接抛异常，让上层保持 collecting 状态重试。
    """

    async def _call():
        await _limiter.wait()

        def _task():
            c = _get_client()
            usdt = c.get_contract(USDT_CONTRACT)
            amt = int(Decimal(str(amount)) * (Decimal(10) ** USDT_DECIMALS))
            tx = (
                usdt.functions.transfer(to_addr, amt)
                .with_owner(from_addr)
                .fee_limit(30_000_000)
                .build()
                .sign(PrivateKey(bytes.fromhex(priv_hex)))
                .broadcast()
            )
            receipt = tx.wait()
            # 常见位置：contractResult/receipt/result/ret 等；tronpy 回执结构可能因节点差异略不同
            result = (
                (receipt.get("receipt") or {}).get("result")
                or receipt.get("contractRet")
                or ""
            )
            result = str(result).upper()
            if result != "SUCCESS":
                raise RuntimeError(
                    f"transfer receipt not SUCCESS: {result}  txid={tx.txid}"
                )

            collect_logger.info(f"✅ USDT 转账确认成功：txid={tx.txid} result={result}")
            return tx.txid

        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(None, _task)

    return await _retry_with_backoff(_call)


# ========== 地址校验 ==========
# 轻量级格式校验：T 开头 + 34 位 Base58 字符（排除 0 O I l）
_BASE58_RE = re.compile(r"^T[1-9A-HJ-NP-Za-km-z]{33}$")


def is_valid_address(address: str) -> bool:
    """
    仅做**快速格式校验**（Base58Check 的弱校验）：
    - 以 'T' 开头
    - 长度 34
    - 仅包含 Base58 字符（排除 0 O I l）
    如果需要更严格的链上校验，可在上层调用 `get_usdt_balance(address)` 等读链接口进一步验证。
    """
    if not isinstance(address, str):
        return False
    if not _BASE58_RE.match(address):
        return False
    return True


