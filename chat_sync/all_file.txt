=== scripts/apply_assistant_patch.sh ===
#!/usr/bin/env bash
set -euo pipefail
PATCH=${1:-assistant.patch}
test -f "$PATCH" || { echo "ç¼ºå°‘è¡¥ä¸æ–‡ä»¶ $PATCH"; exit 1; }
git checkout -b assistant/local-$(date +%s)
git apply --whitespace=fix "$PATCH"
git add -A
git commit -m "chore: apply assistant patch locally"
git push -u origin HEAD
echo ">> å·²æ¨é€åˆ°è¿œç«¯ï¼Œå»ºè®®å‘èµ· PR åˆå¹¶ã€‚"


=== scripts/audit_repo.py ===
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
redpag_bot æœ¬åœ°ä½“æ£€è„šæœ¬
é€é¡¹æ£€æŸ¥ä»¥ä¸‹è½åœ°æƒ…å†µï¼ˆæ‰“å° âœ…/âŒï¼‰ï¼š
  1. å……å€¼æˆåŠŸååˆ·æ–°é¡µï¼šåˆ°è´¦é‡‘é¢+å½“å‰ä½™é¢ã€äºŒç»´ç ç¼©æ”¾å å­—ã€CODEå¤åˆ¶æ ·å¼ï¼ˆå¼¹çª—ï¼‰
  2. â€œæˆ‘çš„é’±åŒ…â€ä¸å†æ˜¾ç¤ºâ€œå……å€¼åœ°å€ï¼ˆä¸“å±ï¼‰â€
  3. æ“ä½œç»“æŸåå›æ˜¾ä¸»èœå•ï¼ˆç»Ÿä¸€ show_main_menuï¼‰
  4. åŠŸèƒ½é”ï¼šçº¢åŒ…/æç°å…¥å£æ‹¦æˆªï¼ˆsys_flags.lock_redpacket / lock_withdrawï¼‰
  5. é‡‘é¢æ˜¾ç¤ºä¸¤ä½å°æ•°ï¼ˆfmt_amountï¼‰
  6. Bot Menuï¼šset_my_commands / chat menu
  7. å……å€¼ç›´æ¥å¼¹çª—ï¼ˆreply_photo + InlineKeyboardï¼‰
  8. ä»…å¤„ç†ç§èŠï¼ˆfilters.ChatType.PRIVATEï¼‰
  9. åœ°å€æŸ¥è¯¢ï¼šTRX/USDTä½™é¢ã€èµ„æºã€æœ€è¿‘10ç¬”è½¬è´¦ï¼›éæ³•æ ¼å¼æç¤º
 10. ä¹å®«æ ¼äº¤æ˜“å¯†ç 
 11. çº¢åŒ…ç±»å‹å¯åˆ‡æ¢ï¼ˆéšæœº|å¹³å‡|ä¸“å±ï¼‰å¹¶æœ‰â€œå½“å‰é€‰ä¸­â€æŒ‡ç¤º
 12. å½’é›†æˆåŠŸåï¼šç§èŠç”¨æˆ·é€šçŸ¥ + å¯¹è´¦é”ï¼ˆèšåˆåœ°å€ USDT vs ç”¨æˆ·æ€»ä½™é¢ï¼‰
"""
import pathlib, re

ROOT = pathlib.Path(__file__).resolve().parents[1]
SRC = ROOT / "src"

def ok(msg): print("âœ…", msg)
def ng(msg): print("âŒ", msg)

def rd(p: pathlib.Path) -> str:
    try:
        return p.read_text(encoding="utf-8")
    except Exception:
        return ""

def has(p: pathlib.Path, *pats) -> bool:
    s = rd(p)
    return s and all(re.search(x, s, re.S) for x in pats)

# 1 å……å€¼æˆåŠŸå±•ç¤º
def check_recharge_success():
    p = SRC / "handlers" / "recharge.py"
    s = rd(p)
    if not s: return ng("ç¼ºæ–‡ä»¶ï¼šsrc/handlers/recharge.py")
    a = ("recharge_status" in s) and (("åˆ°è´¦é‡‘é¢" in s) or ("get_ledger_amount_by_ref" in s) or ("ledger" in s))
    b = ("reply_photo" in s and ("make_qr_png_bytes" in s or "qrcode" in s))
    c = ("ç‚¹å‡»å¤åˆ¶" in s and "`" in s)
    if a: ok("å……å€¼æˆåŠŸæ˜¾ç¤ºåˆ°è´¦é‡‘é¢+å½“å‰ä½™é¢ OK")
    else: ng("å……å€¼æˆåŠŸé¡µæœªæ£€æµ‹åˆ° åˆ°è´¦é‡‘é¢/ä½™é¢ åˆ·æ–°")
    if b: ok("å……å€¼å¼¹çª—/äºŒç»´ç ç¼©æ”¾ OK")
    else: ng("å……å€¼æœªè§å¼¹çª—æˆ–äºŒç»´ç ç¼©æ”¾")
    if c: ok("åœ°å€/è®¢å•å· CODE æ ·å¼ OK")
    else: ng("æœªæ£€æµ‹åˆ° CODE æ ·å¼ â€˜`...`  ğŸ‘ˆ ç‚¹å‡»å¤åˆ¶â€™")

# 2 é’±åŒ…é¡µä¸æ˜¾ç¤ºâ€œå……å€¼åœ°å€ï¼ˆä¸“å±ï¼‰â€
def check_wallet_page():
    p = SRC / "handlers" / "wallet.py"
    s = rd(p)
    if not s: return ng("ç¼ºæ–‡ä»¶ï¼šsrc/handlers/wallet.py")
    if ("å……å€¼åœ°å€" in s and "ä¸“å±" in s):
        ng("æˆ‘çš„é’±åŒ…ä»å‡ºç°â€œå……å€¼åœ°å€ï¼ˆä¸“å±ï¼‰â€å­—æ ·")
    else:
        ok("æˆ‘çš„é’±åŒ…æœªæ˜¾ç¤ºâ€œå……å€¼åœ°å€ï¼ˆä¸“å±ï¼‰â€ OK")

# 3 æ“ä½œç»“æŸå›æ˜¾ä¸»èœå•
def check_show_menu():
    any_hit = False
    for name in ["recharge.py","addr_query.py","red_packet.py","withdraw.py","password.py","wallet.py"]:
        p = SRC / "handlers" / name
        if p.exists() and "show_main_menu" in rd(p):
            any_hit = True; break
    if any_hit:
        ok("ç»“æŸåå›æ˜¾ä¸»èœå•ï¼ˆshow_main_menuï¼‰å·²åœ¨å¤šä¸ª handler ä½¿ç”¨")
    else:
        ng("æœªæ£€æµ‹åˆ° show_main_menu ç”¨äºå›æ˜¾ä¸»èœå•")

# 4 åŠŸèƒ½é”
def check_feature_locks():
    rp = SRC / "handlers" / "red_packet.py"
    wd = SRC / "handlers" / "withdraw.py"
    rp_ok = rp.exists() and ("lock_redpacket" in rd(rp))
    wd_ok = wd.exists() and ("lock_withdraw" in rd(wd))
    if rp_ok and wd_ok:
        ok("åŠŸèƒ½é”å…¥å£æ‹¦æˆªï¼ˆçº¢åŒ…/æç°ï¼‰OK")
    else:
        ng("åŠŸèƒ½é”å…¥å£æ‹¦æˆªå­˜åœ¨ç¼ºå£ï¼ˆæ£€æŸ¥ get_flag('lock_*')ï¼‰")

# 5 é‡‘é¢ç»Ÿä¸€ä¸¤ä½å°æ•°
def check_fmt_amount():
    common = SRC / "handlers" / "common.py"
    s = rd(common)
    if s and ("def fmt_amount" in s and ".2f" in s):
        ok("fmt_amount ä¸¤ä½å°æ•° OK")
    else:
        ng("æœªæ£€æµ‹åˆ° fmt_amount æˆ–æœªç»Ÿä¸€ä¸¤ä½å°æ•°ï¼ˆhandlers/common.pyï¼‰")

# 6 Bot Menu
def check_menu_register():
    p = SRC / "main.py"
    s = rd(p)
    if s and ("set_my_commands" in s or "set_chat_menu_button" in s):
        ok("Bot Menu æ³¨å†Œ OK")
    else:
        ng("æœªæ£€æµ‹åˆ° set_my_commands / set_chat_menu_button")

# 7 å……å€¼å¼¹çª—
def check_popup_recharge():
    p = SRC / "handlers" / "recharge.py"
    s = rd(p)
    if s and ("reply_photo" in s and "InlineKeyboard" in s):
        ok("å……å€¼å¼¹çª—ï¼ˆäºŒç»´ç +æŒ‰é’®ï¼‰OK")
    else:
        ng("å……å€¼å¼¹çª—æœªæ£€æµ‹åˆ° reply_photo/InlineKeyboard")

# 8 ä»…ç§èŠ
def check_private_only():
    p = SRC / "main.py"
    s = rd(p)
    if s and (re.search(r"ChatType\\.?PRIVATE", s) or "filters.ChatType.PRIVATE" in s):
        ok("ä»…å¤„ç†ç§èŠ OK")
    else:
        ng("æœªæ£€æµ‹åˆ°ä»…ç§èŠè¿‡æ»¤ï¼ˆfilters.ChatType.PRIVATEï¼‰")

# 9 åœ°å€æŸ¥è¯¢å¢å¼º
def check_addr_query():
    p = SRC / "handlers" / "addr_query.py"
    s = rd(p)
    if not s: return ng("ç¼ºæ–‡ä»¶ï¼šsrc/handlers/addr_query.py")
    a = ("å½“å‰ä»…æ”¯æŒTRC-20æ ¼å¼åœ°å€" in s) or ("å½“å‰ä»…æ”¯æŒ TRC-20 æ ¼å¼åœ°å€" in s)
    b = ("get_trx_balance" in s and "get_trc20_balance" in s and "get_account_resource" in s)
    c = ("get_recent_transfers" in s)
    if a and b and c:
        ok("åœ°å€æŸ¥è¯¢ï¼šæ ¡éªŒ+ä½™é¢+èµ„æº+æœ€è¿‘10ç¬” OK")
    else:
        ng("åœ°å€æŸ¥è¯¢æœªå®Œå…¨å®ç°ï¼ˆæˆ–å‡½æ•°è°ƒç”¨æœªå‘½ä¸­ï¼‰")

# 10 ä¹å®«æ ¼äº¤æ˜“å¯†ç 
def check_password_grid():
    p = SRC / "handlers" / "password.py"
    s = rd(p)
    if s and ("InlineKeyboardButton" in s and "â€¢" in s or "â—" in s):
        ok("ä¹å®«æ ¼äº¤æ˜“å¯†ç  UI OK")
    else:
        ng("æœªæ£€æµ‹åˆ°ä¹å®«æ ¼å¯†ç  UI")

# 11 çº¢åŒ…ç±»å‹åˆ‡æ¢
def check_redpacket_types():
    p = SRC / "handlers" / "red_packet.py"
    s = rd(p)
    if s and ("éšæœº" in s and "å¹³å‡" in s and "ä¸“å±" in s and "set_rp_type" in s):
        ok("çº¢åŒ…ç±»å‹å¯åˆ‡æ¢ï¼ˆéšæœº|å¹³å‡|ä¸“å±ï¼‰OK")
    else:
        ng("çº¢åŒ…ç±»å‹åˆ‡æ¢åŠŸèƒ½æœªæ£€æµ‹åˆ°ï¼ˆæˆ–ç¼ºå°‘æŒ‡ç¤ºå½“å‰é€‰ä¸­ï¼‰")

# 12 å½’é›†æˆåŠŸé€šçŸ¥ + å¯¹è´¦é”
def check_collector_notify_reconcile():
    p = SRC / "collectors" / "recharge_collector.py"
    s = rd(p)
    if not s: return ng("ç¼ºæ–‡ä»¶ï¼šsrc/collectors/recharge_collector.py")
    a = ("send_message" in s and "å……å€¼æˆåŠŸ" in s) or ("_notify" in s and "success" in s)
    b = ("sum_user_usdt_balance" in s and "get_trc20_balance" in s and ("set_flag(\"lock_" in s or "lock_" in s))
    if a: ok("å½’é›†æˆåŠŸåç”¨æˆ·é€šçŸ¥ OK")
    else: ng("å½’é›†æˆåŠŸåç”¨æˆ·é€šçŸ¥æœªæ£€æµ‹åˆ°")
    if b: ok("å¯¹è´¦ + é”å¼€å…³ æ ¡éªŒ OK")
    else: ng("å¯¹è´¦/é”å¼€å…³é€»è¾‘æœªæ£€æµ‹åˆ°")

def main():
    print("=== redpag_bot æœ¬åœ°ä½“æ£€ ===")
    check_recharge_success()
    check_wallet_page()
    check_show_menu()
    check_feature_locks()
    check_fmt_amount()
    check_menu_register()
    check_popup_recharge()
    check_private_only()
    check_addr_query()
    check_password_grid()
    check_redpacket_types()
    check_collector_notify_reconcile()
    print("=== ä½“æ£€ç»“æŸ ===")

if __name__ == "__main__":
    main()


=== scripts/make_chat_bundle.sh ===
#!/usr/bin/env bash
set -euo pipefail
OUT=chat_sync_bundle.tgz
mkdir -p chat_sync
echo "Commit: $(git rev-parse HEAD)" > chat_sync/GIT_HEAD.txt
echo "Date: $(date -u +'%F %T UTC')" >> chat_sync/GIT_HEAD.txt
find src scripts -type f | sort > chat_sync/file_list.txt
> chat_sync/all_file.txt
while IFS= read -r f; do
  if file "$f" | grep -qi "text"; then
    echo "=== $f ===" >> chat_sync/all_file.txt
    cat "$f" >> chat_sync/all_file.txt
    echo -e "\n" >> chat_sync/all_file.txt
  fi
done < chat_sync/file_list.txt
if [ -f scripts/audit_repo.py ]; then
  python3 scripts/audit_repo.py > chat_sync/audit_report.txt || true
fi
tar czf "$OUT" chat_sync
echo ">> ç”Ÿæˆå®Œæˆï¼š$OUTï¼ˆè¯·ä¸Šä¼ åˆ°èŠå¤©ï¼‰"


=== scripts/repo_audit_strict.py ===
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ä¸¥æ ¼ä½“æ£€ï¼š
1) æ‰«æ py39 ä¸å…¼å®¹çš„ unionï¼ˆ" | None"ï¼‰
2) ç»Ÿè®¡ models.py å®šä¹‰çš„å‡½æ•°/å¸¸é‡ï¼Œå¹¶æ ¸å¯¹ handlers / services é‡Œçš„ import ä½¿ç”¨
3) ç²—ç•¥æ‰¾â€œæœªä½¿ç”¨çš„ models å‡½æ•°â€
4) æ•æ‰è£¸ exceptã€å¹¿ä¹‰ exceptã€print è°ƒè¯•æ®‹ç•™
5) è§¦å‘ä¸€æ¬¡ compileallï¼ˆèƒ½å¿«é€Ÿå‘ç°è¯­æ³•/ç¼©è¿›ç­‰ç¡¬é”™è¯¯ï¼‰

ç”¨æ³•ï¼š
    python3 scripts/repo_audit_strict.py
"""
import os, re, sys, ast, compileall
from pathlib import Path
ROOT = Path(__file__).resolve().parent.parent
SRC = ROOT / "src"

def read(p: Path) -> str:
    return p.read_text(encoding="utf-8", errors="ignore")

def iter_py():
    for p in SRC.rglob("*.py"):
        if any(x in p.parts for x in ("__pycache__",)):
            continue
        yield p

def find_py39_union():
    bad = []
    rx = re.compile(r"\|\s*None\b")
    for p in iter_py():
        txt = read(p)
        for i, line in enumerate(txt.splitlines(), 1):
            if rx.search(line):
                bad.append((p, i, line.strip()))
    return bad

def ast_defs_calls_in_models(models: Path):
    txt = read(models)
    tree = ast.parse(txt, filename=str(models))
    defs = set()
    for n in ast.walk(tree):
        if isinstance(n, (ast.FunctionDef, ast.AsyncFunctionDef)):
            defs.add(n.name)
        if isinstance(n, ast.Assign):
            for t in n.targets:
                if isinstance(t, ast.Name):
                    defs.add(t.id)
    return defs

def imported_from_models():
    used = set()
    rx = re.compile(r"from\s+\.{1,2}models\s+import\s+(.+)")
    for p in iter_py():
        if p.name == "models.py":
            continue
        for m in rx.finditer(read(p)):
            names = [x.strip().split(" as ")[0] for x in m.group(1).split(",")]
            for n in names:
                if n:
                    used.add(n)
    return used

def grep_usage(name: str):
    # ç²—ç³™ï¼šå…¨ä»“æ–‡æœ¬æœç´¢
    pat = re.compile(r"\b" + re.escape(name) + r"\b")
    hits = []
    for p in iter_py():
        for i, line in enumerate(read(p).splitlines(), 1):
            if pat.search(line):
                hits.append((p, i, line.strip()))
    return hits

def scan_broad_except():
    items = []
    rx_bare = re.compile(r"^\s*except\s*:\s*$")
    rx_broad = re.compile(r"^\s*except\s+\((Exception|BaseException)\)\s*:\s*$")
    for p in iter_py():
        for i, line in enumerate(read(p).splitlines(), 1):
            if rx_bare.match(line) or rx_broad.match(line):
                items.append((p, i, line.strip()))
    return items

def scan_prints():
    items = []
    rx = re.compile(r"^\s*print\(")
    for p in iter_py():
        for i, line in enumerate(read(p).splitlines(), 1):
            if rx.match(line):
                items.append((p, i, line.strip()))
    return items

def main():
    print("=== ä¸¥æ ¼ä½“æ£€ï¼ˆpy39 å…¼å®¹ & ç¬¦å·æ ¸å¯¹ & ç²—ç•¥æ­»ä»£ç  & å¼‚å¸¸è§„èŒƒ & ç¼–è¯‘æ£€æŸ¥ï¼‰ ===")

    unions = find_py39_union()
    if unions:
        print("\n[!] å‘ç° py3.9 ä¸å…¼å®¹çš„ union æ ‡æ³¨ï¼ˆè¯·æ”¹ä¸º Optional[...]ï¼‰:")
        for p,i,l in unions:
            print(f" - {p}:{i}: {l}")
    else:
        print("\n[OK] æœªå‘ç° ' | None' ç­‰ py39 ä¸å…¼å®¹ union")

    models = SRC / "models.py"
    if models.exists():
        defs = ast_defs_calls_in_models(models)
        used = imported_from_models()
        missing = sorted(n for n in used if n not in defs)
        if missing:
            print("\n[!] å…¶ä»–æ¨¡å—å¼•è‡ª models ä½† models æœªå®šä¹‰ï¼š")
            for n in missing:
                print(f" - {n}")
        else:
            print("\n[OK] models ä¸­èƒ½æ‰¾åˆ°æ‰€æœ‰è¢« import çš„ç¬¦å·")

        # ç²—ç•¥â€œæœªè¢«ä½¿ç”¨â€çš„å®šä¹‰ï¼ˆæ’é™¤å¸¸è§ä¿ç•™ï¼‰
        ignore = {"__all__", "__version__", "__doc__"}
        unused = []
        for name in sorted(d for d in defs if not d.startswith("_") and d not in ignore):
            hits = grep_usage(name)
            # ä»…åœ¨ models è‡ªèº«è¢«å®šä¹‰ï¼Œä¸åœ¨å…¶ä»–å¤„è¢«å¼•ç”¨
            if all(str(p).endswith("/models.py") for p,_,_ in hits):
                unused.append(name)
        if unused:
            print("\n[?] å¯èƒ½æœªä½¿ç”¨çš„ models ç¬¦å·ï¼ˆè¯·äººå·¥å¤æ ¸ï¼ŒæŸäº›å¯èƒ½ä¾› SQL/åå°„è°ƒç”¨ï¼‰ï¼š")
            for n in unused:
                print(f" - {n}")
        else:
            print("\n[OK] æœªå‘ç°æ˜æ˜¾æœªä½¿ç”¨çš„ models ç¬¦å·")

    excs = scan_broad_except()
    if excs:
        print("\n[!] å‘ç°è£¸/è¿‡å®½ exceptï¼ˆå»ºè®®æ”¹ä¸ºç²¾ç¡®å¼‚å¸¸/åŠ æ—¥å¿—ï¼‰ï¼š")
        for p,i,l in excs:
            print(f" - {p}:{i}: {l}")
    else:
        print("\n[OK] æœªå‘ç°è£¸/è¿‡å®½ except")

    prints = scan_prints()
    if prints:
        print("\n[?] å‘ç° print è°ƒè¯•è¾“å‡ºï¼ˆå»ºè®®æ”¹ä¸º loggerï¼‰ï¼š")
        for p,i,l in prints:
            print(f" - {p}:{i}: {l}")
    else:
        print("\n[OK] æœªå‘ç° print è°ƒè¯•è¾“å‡º")

    print("\n[*] è¿›è¡Œç¼–è¯‘æ£€æŸ¥ï¼ˆcompileallï¼‰...")
    ok = compileall.compile_dir(str(SRC), quiet=1, force=False)
    if ok:
        print("[OK] compileall ç¼–è¯‘é€šè¿‡")
    else:
        print("[X] compileall æœ‰é”™è¯¯ï¼ˆè¯·æŸ¥çœ‹ä¸Šæ–¹æŠ¥é”™å¹¶ä¿®å¤ï¼‰")

if __name__ == "__main__":
    main()


=== src/collectors/recharge_collector.py ===
import asyncio
import time

from ..config import AGGREGATE_ADDRESS, MIN_DEPOSIT_USDT, USDT_CONTRACT
from ..db import close_pool, init_pool
from ..models import (
    add_energy_rent_log,
    add_ledger,
    has_active_energy_rent,
    ledger_exists_for_ref,
    set_flag,
    set_recharge_status,
    sum_user_usdt_balance,
)
from ..services.energy import rent_energy
from ..services.tron import get_account_resource, get_trc20_balance, get_usdt_balance

bot = Bot(BOT_TOKEN)


async def _notify_success(user_id: int, order_no: str, amt: float, new_bal: float):
    txt = (
        f"âœ… å……å€¼æˆåŠŸ\n"
        f"è®¢å•å·ï¼š`{order_no}`\n"
        f"åˆ°è´¦é‡‘é¢ï¼š**{amt:.2f} USDT**\n"
        f"å½“å‰ä½™é¢ï¼š**{new_bal:.2f} USDT**"
    )
    await bot.send_message(chat_id=user_id, text=txt, parse_mode="Markdown")


async def _reconcile_and_lock():
    # èšåˆåœ°å€ä½™é¢ vs ç”¨æˆ·æ€»ä½™é¢
    agg = await get_trc20_balance(AGGREGATE_ADDRESS, USDT_CONTRACT)
    total = await sum_user_usdt_balance()
    # è§„åˆ™ï¼šæ€»ä½™é¢ <= èšåˆä½™é¢ ä¸ºæ­£å¸¸ï¼Œå¦åˆ™é”åŠŸèƒ½
    need_lock = total > agg + 1e-8
    await set_flag("lock_withdraw", need_lock)
    await set_flag("lock_redpacket", need_lock)


EXPIRE_SQL = "UPDATE recharge_orders SET status='expired' WHERE status='waiting' AND expire_at <= NOW()"


def _safe_notes(s: str) -> str:
    return re.sub(r"[^\u4e00-\u9fa5A-Za-z0-9_-]", "", s)


async def _wait_energy_ready(
    addr: str, need_energy: int, timeout: int = None, poll_interval: int = None
) -> bool:
    """
    è½®è¯¢ç­‰å¾…èƒ½é‡ç”Ÿæ•ˆï¼šç›´åˆ°èƒ½é‡ >= need_energy æˆ–ç­‰å¾…è¾¾åˆ° timeoutã€‚
    - timeout ä»ç¯å¢ƒå˜é‡ TRONGAS_ACTIVATION_DELAY è¯»ï¼ˆé»˜è®¤ 30sï¼‰
    - poll_interval ä»ç¯å¢ƒå˜é‡ TRONGAS_POLL_INTERVAL è¯»ï¼ˆé»˜è®¤ 3sï¼‰
    """
    from ..logger import collect_logger
    from ..services.tron import get_account_resource  # é¿å…å¾ªç¯å¯¼å…¥ï¼Œæ”¾åœ¨å‡½æ•°å†…

    timeout = (
        int(os.getenv("TRONGAS_ACTIVATION_DELAY", "30"))
        if timeout is None
        else int(timeout)
    )
    poll_interval = (
        int(os.getenv("TRONGAS_POLL_INTERVAL", "3"))
        if poll_interval is None
        else int(poll_interval)
    )

    start = time.monotonic()
    # å…ˆæ‰“ä¸€æ¬¡å¿«ç…§
    res = get_account_resource(addr)
    if res.get("energy", 0) >= need_energy:
        used = time.monotonic() - start
        collect_logger.info(
            f"âœ… èƒ½é‡å·²å°±ç»ªï¼š{res['energy']} â‰¥ {need_energy}ï¼ˆç”¨æ—¶ {used:.1f}sï¼Œtimeout={timeout}sï¼‰"
        )
        return True

    while True:
        elapsed = time.monotonic() - start
        if elapsed >= timeout:
            collect_logger.info(
                f"âŒ› ç­‰å¾…èƒ½é‡è¶…æ—¶ï¼š{res['energy']} < {need_energy}ï¼ˆå·²ç­‰ {elapsed:.1f}s / {timeout}sï¼‰"
            )
            return False

        left = min(poll_interval, max(1, timeout - int(elapsed)))
        collect_logger.info(
            f"â³ ç­‰å¾…èƒ½é‡ç”Ÿæ•ˆ {int(elapsed)}s/{timeout}sï¼šå½“å‰ {res['energy']} < {need_energy}ï¼Œ{left}s åé‡æŸ¥â€¦"
        )
        await asyncio.sleep(left)

        # é‡æŸ¥èµ„æº
        res = get_account_resource(addr)
        if res.get("energy", 0) >= need_energy:
            used = time.monotonic() - start
            collect_logger.info(
                f"âœ… èƒ½é‡å·²å°±ç»ªï¼š{res['energy']} â‰¥ {need_energy}ï¼ˆç”¨æ—¶ {used:.1f}s / {timeout}sï¼‰"
            )
            return True


def _log_resource_snapshot(
    addr: str,
    usdt_bal: float,
    res: dict,
    need_energy: int,
    need_bw: int,
    trx_bal: float,
    prefix: str = "ğŸ” èµ„æºå¿«ç…§",
):
    collect_logger.info(
        f"{prefix}ï¼š\n"
        f"  â€¢ åœ°å€ï¼š{addr}\n"
        f"  â€¢ USDTä½™é¢ï¼š{usdt_bal:.6f}\n"
        f"  â€¢ èƒ½é‡ï¼š{res['energy']} / éœ€è¦ {need_energy}\n"
        f"  â€¢ å¸¦å®½ï¼š{res['bandwidth']} / å»ºè®® {need_bw}\n"
        f"  â€¢ TRXä½™é¢ï¼š{trx_bal:.6f}"
    )


async def _precheck_and_prepare(
    uid: int, addr: str, oid: int, order_no: str
) -> Tuple[bool, float]:
    need_energy = int(os.getenv("USDT_ENERGY_REQUIRE", "90000"))
    need_bw = int(os.getenv("MIN_BANDWIDTH", "800"))
    min_deposit = float(os.getenv("MIN_DEPOSIT_USDT", "10"))
    min_trx_for_bw = float(os.getenv("MIN_TRX_FOR_BANDWIDTH", "1.0"))
    trx_topup_target = float(os.getenv("TRX_TOPUP_TARGET", "2.0"))
    rent_retry_sec = int(os.getenv("ENERGY_RENT_RETRY_SECONDS", "120"))

    # ä½™é¢
    usdt_bal = await get_usdt_balance(addr)
    res0 = get_account_resource(addr)
    trx_bal0 = get_trx_balance(addr)
    _log_resource_snapshot(
        addr,
        usdt_bal,
        res0,
        need_energy,
        need_bw,
        trx_bal0,
        prefix="ğŸ” èµ„æºå¿«ç…§ï¼ˆé¢„æ£€å‰ï¼‰",
    )

    if usdt_bal < min_deposit:
        collect_logger.info(
            f"â¸ USDTä¸è¶³ï¼š{usdt_bal:.6f} < {min_deposit:.2f}ï¼Œæœ¬è½®ä¸å½’é›†"
        )
        return False, usdt_bal

    # â€”â€” èƒ½é‡ä¿éšœï¼šä¸è¶³å°±ç§Ÿï¼Œå“ªæ€•å·²æœ‰æœ‰æ•ˆç§Ÿå•ï¼Œä½† energy ä»è¾¾ä¸åˆ°é˜ˆå€¼ï¼Œä¹Ÿä¼šæ ¹æ®æœ€å°é—´éš”å†æ¬¡ç§Ÿ â€”â€” #
    if res0["energy"] < need_energy:
        can_rent = True
        ago = await last_energy_rent_seconds_ago(addr)
        if ago < rent_retry_sec:
            can_rent = False
            collect_logger.info(
                f"â³ è·ç¦»ä¸Šæ¬¡ç§Ÿèƒ½é‡ {ago}s < {rent_retry_sec}sï¼Œæš‚ä¸é‡å¤ä¸‹å•ï¼ˆé¿å…é¢‘ç¹ä¸‹å•ï¼‰"
            )

        if can_rent:
            try:
                min_rent = int(os.getenv("TRONGAS_MIN_RENT", "32000"))
                step = max(int(os.getenv("TRONGAS_RENT_STEP", "1000")), 1)
                gap = max(need_energy - res0["energy"], min_rent)
                gap = ((gap + step - 1) // step) * step
                collect_logger.info(
                    f"âš¡ è®¡åˆ’ç§Ÿèƒ½é‡ï¼šç¼ºå£â‰ˆ{need_energy - res0['energy']}ï¼Œä¸‹å•é‡={gap}ï¼ˆmin={min_rent}, step={step}ï¼‰"
                )
                resp = await rent_energy(
                    receive_address=addr,
                    pay_nums=gap,
                    rent_time=1,
                    order_notes=f"order-{order_no}",
                )

                rid = (resp or {}).get("orderId") or (resp or {}).get("order_id")
                await add_energy_rent_log(
                    addr, oid, order_no, rent_order_id=str(rid), ttl_seconds=3600
                )
                collect_logger.info(f"âš¡ å·²ç§Ÿèƒ½é‡ gapâ‰ˆ{gap}ï¼šorder_id={rid}ï¼Œç­‰å¾…ç”Ÿæ•ˆâ€¦")
            except Exception as e:
                collect_logger.error(f"âŒ ç§Ÿèƒ½é‡å¤±è´¥ï¼š{e}ï¼›å…ˆä¸å½’é›†")
                return False, usdt_bal

        ok = await _wait_energy_ready(
            addr, need_energy, timeout=int(os.getenv("TRONGAS_ACTIVATION_DELAY", "30"))
        )
        res1 = get_account_resource(addr)
        trx_bal1 = get_trx_balance(addr)
        _log_resource_snapshot(
            addr,
            usdt_bal,
            res1,
            need_energy,
            need_bw,
            trx_bal1,
            prefix="ğŸ” èµ„æºå¿«ç…§ï¼ˆç§Ÿèƒ½é‡åï¼‰",
        )
        if res1["energy"] < need_energy:
            collect_logger.info(
                f"â¸ èƒ½é‡ä»ä¸è¶³ï¼š{res1['energy']} < {need_energy}ï¼Œæœ¬è½®ä¸å½’é›†"
            )
            return False, usdt_bal
        res0 = res1
        trx_bal0 = trx_bal1

    # â€”â€” å¸¦å®½ä¿éšœï¼šæ”¾å®½ä¸ºâ€œå¸¦å®½â‰¥é˜ˆå€¼ æˆ– TRXä½™é¢â‰¥æœ€å°å€¼â€ â€”â€” #
    if res0["bandwidth"] < need_bw and trx_bal0 < min_trx_for_bw:
        fee_from = os.getenv("FEE_PAYER_ADDRESS")
        fee_priv = os.getenv("FEE_PAYER_PRIVKEY_HEX")
        if not (fee_from and fee_priv):
            collect_logger.warning(
                f"âš ï¸ å¸¦å®½ä¸è¶³ä¸” TRX ä½™é¢({trx_bal0:.6f})<æœ€å°å€¼({min_trx_for_bw})ï¼Œä¸”æœªé…ç½®ä»£ä»˜è´¦å·ï¼Œæ— æ³•ä¿éšœå¸¦å®½"
            )
            return False, usdt_bal

        # ä»£ä»˜é‡‘é¢ = ç›®æ ‡ - å½“å‰ï¼ˆç•™å‡º0.1å®‰å…¨ä½™é‡ï¼‰
        need_topup = max(0.0, trx_topup_target - trx_bal0 + 0.1)
        try:
            txid = send_trx(fee_priv, fee_from, addr, need_topup)
            collect_logger.info(
                f"ğŸª™ ä»£ä»˜ TRX {need_topup:.6f} â†’ {addr} æˆåŠŸï¼Œtxid={txid}"
            )
            await asyncio.sleep(3)
        except Exception as e:
            collect_logger.error(f"âŒ ä»£ä»˜å¤±è´¥ï¼š{e}ï¼›æœ¬è½®ä¸å½’é›†")
            return False, usdt_bal

        res2 = get_account_resource(addr)
        trx_bal2 = get_trx_balance(addr)
        _log_resource_snapshot(
            addr,
            usdt_bal,
            res2,
            need_energy,
            need_bw,
            trx_bal2,
            prefix="ğŸ” èµ„æºå¿«ç…§ï¼ˆä»£ä»˜åï¼‰",
        )
        # ä»£ä»˜åå³ä¾¿å¸¦å®½å­—æ®µä»<é˜ˆå€¼ï¼Œåªè¦ TRXâ‰¥æœ€å°å€¼å°±å…è®¸ç»§ç»­ï¼ˆé çƒ§è´¹ï¼‰
        if trx_bal2 < min_trx_for_bw:
            collect_logger.info(
                f"â¸ ä»£ä»˜å TRX ä½™é¢ä»ä¸è¶³ï¼š{trx_bal2:.6f} < {min_trx_for_bw}ï¼Œæœ¬è½®ä¸å½’é›†"
            )
            return False, usdt_bal

    return True, usdt_bal


async def _ensure_resources(addr: str, oid: int, order_no: str) -> None:
    """ç¡®ä¿è¯¥åœ°å€æœ¬æ¬¡å½’é›†çš„ èƒ½é‡+å¸¦å®½ è¶³å¤Ÿï¼›1å°æ—¶å†…ä¸é‡å¤ç§Ÿèƒ½é‡ï¼›å¸¦å®½ä¸è¶³è‡ªåŠ¨TRXä»£ä»˜"""
    res = get_account_resource(addr)
    need_energy = int(os.getenv("USDT_ENERGY_REQUIRE", "30000"))
    need_bw = int(os.getenv("MIN_BANDWIDTH", "500"))

    # â€”â€” èƒ½é‡ï¼šè‹¥ä¸è¶³ä¸” 1h å†…æ— æœ‰æ•ˆç§Ÿå•åˆ™ä¸‹å• â€”â€” #
    if res["energy"] < need_energy and not await has_active_energy_rent(addr):
        try:
            resp = await rent_energy(
                receive_address=addr,
                pay_nums=max(need_energy - res["energy"], 20000),  # è‡³å°‘ç§Ÿ 20k
                rent_time=1,
                order_notes=_safe_notes(f"order-{order_no}"),
            )
            order_id = (resp or {}).get("order_id")
            await add_energy_rent_log(
                addr, oid, order_no, rent_order_id=str(order_id), ttl_seconds=3600
            )
            collect_logger.info(
                f"âš¡ èƒ½é‡ä¸‹å•æˆåŠŸï¼šè®¢å• {oid}ï¼ˆ{order_no}ï¼‰ id={order_id}"
            )
            await asyncio.sleep(int(os.getenv("TRONGAS_ACTIVATION_DELAY", "8")))
            ok = await _wait_energy_ready(
                addr,
                need_energy,
                timeout=int(os.getenv("TRONGAS_ACTIVATION_DELAY", "30")),
            )
            if not ok:
                collect_logger.warning(
                    f"âš ï¸ èƒ½é‡ç§Ÿç”¨å·²ä¸‹å•ä½†æœªåŠæ—¶ç”Ÿæ•ˆï¼Œå½“å‰ energy={get_account_resource(addr)['energy']}"
                )

        except Exception as e:
            collect_logger.error(f"âŒ èƒ½é‡ä¸‹å•å¤±è´¥ï¼š{e}ï¼›ç¨åé‡è¯•")
            # ä¸æŠ›å‡ºï¼Œç»§ç»­æ£€æŸ¥å¸¦å®½ï¼Œä¸‹ä¸€è½®ä¼šå†è¯•
    else:
        collect_logger.info(
            f"âš¡ èƒ½é‡å……è¶³æˆ–å·²æœ‰æœ‰æ•ˆç§Ÿå•ï¼Œè·³è¿‡ç§Ÿèƒ½é‡ï¼ˆå‰©ä½™ {res['energy']}ï¼‰"
        )

    # â€”â€” å¸¦å®½ï¼šè‹¥ä¸è¶³ï¼Œå°è¯• TRX ä»£ä»˜ â€”â€” #
    res = get_account_resource(addr)  # å†æŸ¥ä¸€æ¬¡
    if res["bandwidth"] < need_bw:
        fee_from = os.getenv("FEE_PAYER_ADDRESS")
        fee_priv = os.getenv("FEE_PAYER_PRIVKEY_HEX")
        topup = float(os.getenv("TOPUP_TRX", "1.2"))
        if fee_from and fee_priv and topup > 0:
            try:
                txid = send_trx(fee_priv, fee_from, addr, topup)
                collect_logger.info(
                    f"ğŸª™ å¸¦å®½ä¸è¶³ï¼Œå·²ä» {fee_from} ä»£ä»˜ {topup} TRX â†’ {addr}ï¼Œtxid={txid}"
                )
                await asyncio.sleep(3)  # è®©ä½™é¢å¯è§
            except Exception as e:
                collect_logger.error(f"âŒ TRX ä»£ä»˜å¤±è´¥ï¼š{e}ï¼›ç¨åé‡è¯•")
        else:
            collect_logger.warning(
                f"âš ï¸ å¸¦å®½ä¸è¶³ï¼ˆ{res['bandwidth']} < {need_bw}ï¼‰ï¼Œä¸”æœªé…ç½®ä»£ä»˜è´¦å·ï¼Œå¯èƒ½å¯¼è‡´ BANDWIDTH_ERROR"
            )
    # ä»£ä»˜ä¹‹å
    res2 = get_account_resource(addr)
    collect_logger.info(
        f"ğŸª™ ä»£ä»˜åèµ„æºï¼šå¸¦å®½ {res2['bandwidth']}ã€èƒ½é‡ {res2['energy']}"
    )


async def _collect_and_book(uid: int, addr: str, oid: int, order_no: str):
    """
    1) å…ˆç¡®ä¿èµ„æºï¼ˆèƒ½é‡+å¸¦å®½ï¼‰
    2) å‘èµ· USDT å…¨é¢è½¬è´¦åˆ°å½’é›†åœ°å€
    3) ç½® verifyingï¼›è®°è´¦ï¼ˆå«å¹‚ç­‰ï¼‰
    """
    ok, bal = await _precheck_and_prepare(uid, addr, oid, order_no)
    if not ok:
        collect_logger.info(f"â¸ è®¢å• {oid}ï¼ˆ{order_no}ï¼‰é¢„æ£€æœªé€šè¿‡ï¼Œè·³è¿‡æœ¬è½®å½’é›†")
        return None
    bal = await get_usdt_balance(addr)
    if bal <= 0:
        collect_logger.warning(f"âš ï¸ è®¢å• {oid}ï¼ˆ{order_no}ï¼‰å‡†å¤‡å½’é›†æ—¶ä½™é¢ä¸º 0ï¼Œè·³è¿‡")
        return None

    # å…ˆç¡®ä¿èµ„æº
    await _ensure_resources(addr, oid, order_no)

    # ç§é’¥
    wallet = await get_wallet(uid)
    priv_enc = wallet.get("tron_privkey_enc")
    if not priv_enc:
        collect_logger.error(
            f"âŒ è®¢å• {oid}ï¼ˆ{order_no}ï¼‰ç”¨æˆ· {uid} æ— ç§é’¥è®°å½•ï¼Œæ— æ³•å½’é›†"
        )
        return None
    priv_hex = decrypt_text(priv_enc)

    # å°è¯•å½’é›†ï¼›å¦‚å› å¸¦å®½æŠ¥é”™ï¼Œè¿›è¡Œä¸€æ¬¡â€œä»£ä»˜åé‡è¯•â€
    try:
        txid = await usdt_transfer_all(priv_hex, addr, AGGREGATE_ADDRESS, float(bal))
    except Exception as e:
        emsg = str(e).upper()
        if "BAND" in emsg or "BANDWITH_ERROR" in emsg or "BANDWIDTH" in emsg:
            collect_logger.warning(f"â›½ é¦–æ¬¡å½’é›†å¸¦å®½æŠ¥é”™ï¼Œå°è¯•TRXä»£ä»˜åé‡è¯•ï¼š{e}")
            await _ensure_resources(addr, oid, order_no)  # é‡Œé¢ä¼šåšä»£ä»˜
            txid = await usdt_transfer_all(
                priv_hex, addr, AGGREGATE_ADDRESS, float(bal)
            )
        else:
            collect_logger.error(
                f"âŒ è®¢å• {oid}ï¼ˆ{order_no}ï¼‰å½’é›†è½¬è´¦å¤±è´¥ï¼š{e}ï¼›ä¿ç•™å½“å‰çŠ¶æ€å¾…é‡è¯•"
            )
            return None

    # â€”â€” æ¨è¿›çŠ¶æ€ & è®°è´¦ï¼ˆä¸ä½ ç°æœ‰é€»è¾‘ä¸€è‡´ï¼Œç•¥ï¼‰ â€”â€” #
    await set_recharge_status(oid, "verifying", txid)
    # å¹‚ç­‰è®°è´¦
    if not await ledger_exists_for_ref("recharge", "recharge_orders", oid):
        before = Decimal(str(wallet["usdt_trc20_balance"] or 0))
        after = before + Decimal(str(bal))
        await update_wallet_balance(uid, float(after))
        await add_ledger(
            uid,
            "recharge",
            float(bal),
            float(before),
            float(after),
            "recharge_orders",
            oid,
            "å……å€¼æˆåŠŸ",
        )
    return txid, float(bal)


async def step_verifying(uid: int, addr: str, oid: int, order_no: str) -> bool:
    """
    verifying æ­¥éª¤ç­–ç•¥ï¼š
    - è‹¥ ledger å·²å­˜åœ¨ â†’ ç›´æ¥ successï¼ˆå¹‚ç­‰ï¼‰
    - å¦åˆ™è¯»å–ä½™é¢ï¼š
        * ä½™é¢â‰ˆ0 â†’ æ ‡è®° success
        * ä½™é¢ >= MIN_DEPOSIT_USDT â†’ å›é€€åˆ° collecting å¹¶ç«‹å³è§¦å‘å½’é›†ï¼ˆç§Ÿèƒ½é‡+è½¬è´¦+è®°è´¦ï¼‰ï¼Œä»ä¿æŒ verifying ç­‰ä¸‹ä¸€è½®ç¡®è®¤
        * ä½™é¢ > 0 ä½† < é˜ˆå€¼ â†’ ä¿æŒ verifyingï¼ˆä¸‹è½®ç»§ç»­çœ‹ï¼‰
    è¿”å›ï¼šæ˜¯å¦å·²ç» success
    """
    # å·²è®°è´¦ â†’ ç›´æ¥æˆåŠŸï¼ˆå¹‚ç­‰ï¼‰
    if await ledger_exists_for_ref("recharge", "recharge_orders", oid):
        await set_recharge_status(oid, "success", None)
        collect_logger.info(f"âœ… è®¢å• {oid} å·²åœ¨ ledger è®°è´¦ï¼šverifying â†’ success")
        await _notify_success(user_id, order_no, credited_amt, new_balance)
        await _reconcile_and_lock()
        return True

    after_bal = await get_usdt_balance(addr)

    # æ¸…é›¶ â†’ æˆåŠŸ
    if after_bal <= 0.000001:
        await set_recharge_status(oid, "success", None)
        collect_logger.info(f"âœ… è®¢å• {oid} éªŒè¯é€šè¿‡ï¼šverifying â†’ successï¼ˆä½™é¢â‰ˆ0ï¼‰")
        return True

    # æœªæ¸…é›¶ï¼Œä½†è¾¾åˆ°é˜ˆå€¼ â†’ å›é€€å¹¶å†æ¬¡å½’é›†
    if float(after_bal) >= float(MIN_DEPOSIT_USDT):
        collect_logger.info(
            f"ğŸ”„ è®¢å• {oid}ï¼ˆ{order_no}ï¼‰éªŒè¯æœŸä½™é¢ä» {after_bal:.6f} â‰¥ é˜ˆå€¼ {MIN_DEPOSIT_USDT:.2f}ï¼Œå›é€€ collecting å¹¶é‡è¯•å½’é›†"
        )
        await set_recharge_status(oid, "collecting", None)
        await _collect_and_book(uid, addr, oid, order_no)
        # å½’é›†åä»ä¿æŒ verifyingï¼Œç­‰å¾…ä¸‹ä¸€è½®ç¡®è®¤æ¸…é›¶
        return False

    # å°é¢æ®‹ç•™ï¼ˆ< é˜ˆå€¼ï¼‰ï¼Œå…ˆä¿æŒ verifying
    collect_logger.warning(
        f"âš ï¸ è®¢å• {oid} éªŒè¯ä»è§ä½™é¢ {after_bal:.6f}ï¼ˆæœªè¾¾é˜ˆå€¼ï¼‰ï¼Œä¿æŒ verifying"
    )
    return False


async def process_waiting(order, counters):
    oid = order["id"]
    uid = order["user_id"]
    addr = order["address"]
    order_no = order.get("order_no") or str(oid)
    collect_logger.info(
        f"ğŸ” æ‰«æ waiting è®¢å•ï¼šid={oid} no={order_no} user={uid} addr={addr}"
    )

    bal = await get_usdt_balance(addr)
    collect_logger.info(
        f"ğŸ“ˆ åœ°å€ä½™é¢ï¼š{addr} = {bal:.6f} USDTï¼ˆé˜ˆå€¼ {MIN_DEPOSIT_USDT:.2f}ï¼‰"
    )

    if float(bal) < float(MIN_DEPOSIT_USDT):
        collect_logger.info(f"â³ è®¢å• {oid} ä»æœªè¾¾æœ€å°é‡‘é¢ï¼Œä¿æŒ waiting")
        counters["waiting_skip"] += 1
        return

    await set_recharge_status(oid, "collecting", None)
    collect_logger.info(f"ğŸšš è®¢å• {oid}ï¼ˆ{order_no}ï¼‰ï¼šwaiting â†’ collecting")
    counters["to_collecting"] += 1

    # ç»Ÿä¸€å½’é›† + è®°è´¦
    ret = await _collect_and_book(uid, addr, oid, order_no)
    if ret is not None:
        counters["collecting_to_verifying"] += 1
        counters["ledger_add"] += 1  # è®°è´¦åœ¨ _collect_and_book å†…åšäº†å¹‚ç­‰ï¼Œè¿™é‡Œç»Ÿè®¡ä¸€ä¸‹


async def process_collecting(order, counters):
    oid = order["id"]
    uid = order["user_id"]
    addr = order["address"]
    order_no = order.get("order_no") or str(oid)
    collect_logger.info(f"ğŸ”§ ç»­è·‘ collecting è®¢å•ï¼šid={oid} no={order_no} user={uid}")

    ret = await _collect_and_book(uid, addr, oid, order_no)
    if ret is not None:
        counters["collecting_to_verifying"] += 1
        counters["ledger_add"] += 1


async def process_verifying(order, counters):
    oid = order["id"]
    uid = order["user_id"]
    addr = order["address"]
    order_no = order.get("order_no") or str(oid)
    collect_logger.info(f"ğŸ” ç»­è·‘ verifying è®¢å•ï¼šid={oid} no={order_no} user={uid}")
    ok = await step_verifying(uid, addr, oid, order_no)
    if ok:
        counters["verifying_to_success"] += 1


async def main_once():
    t0 = time.time()
    counters = {
        "waiting_total": 0,
        "waiting_skip": 0,
        "to_collecting": 0,
        "collecting_total": 0,
        "collecting_to_verifying": 0,
        "verifying_total": 0,
        "verifying_to_success": 0,
        "expired_to_closed": 0,
        "ledger_add": 0,
    }

    await init_pool()
    try:
        # è¿‡æœŸè®¢å•ç½®ä¸º expired
        n = await execute(EXPIRE_SQL) or 0
        counters["expired_to_closed"] = n
        collect_logger.info(f"âŒ› å·²å¤„ç†è¶…æ—¶è®¢å•ï¼šwaitingâ†’expiredï¼Œå…± {n} æ¡")

        # waiting
        waitings = await list_recharge_waiting()
        counters["waiting_total"] = len(waitings)
        for o in waitings:
            try:
                await process_waiting(o, counters)
            except Exception as e:
                collect_logger.exception(f"å¤„ç† waiting è®¢å• {o.get('id')} å¼‚å¸¸ï¼š{e}")

        # collecting
        collings = await list_recharge_collecting()
        counters["collecting_total"] = len(collings)
        for o in collings:
            try:
                await process_collecting(o, counters)
            except Exception as e:
                collect_logger.exception(
                    f"å¤„ç† collecting è®¢å• {o.get('id')} å¼‚å¸¸ï¼š{e}"
                )

        # verifying
        verifs = await list_recharge_verifying()
        counters["verifying_total"] = len(verifs)
        for o in verifs:
            try:
                await process_verifying(o, counters)
            except Exception as e:
                collect_logger.exception(f"å¤„ç† verifying è®¢å• {o.get('id')} å¼‚å¸¸ï¼š{e}")

        # æ±‡æ€»
        dur = time.time() - t0
        collect_logger.info(
            "ğŸ“Š æœ¬è½®å½’é›†æ‰«æç»Ÿè®¡ï¼š\n"
            f"  â€¢ waitingï¼š{counters['waiting_total']}ï¼ˆæ¨è¿›â†’collectingï¼š{counters['to_collecting']}ï¼Œæœªè¾¾é˜ˆå€¼ï¼š{counters['waiting_skip']}ï¼‰\n"
            f"  â€¢ collectingï¼š{counters['collecting_total']}ï¼ˆæ¨è¿›â†’verifyingï¼š{counters['collecting_to_verifying']}ï¼‰\n"
            f"  â€¢ verifyingï¼š{counters['verifying_total']}ï¼ˆæ¨è¿›â†’successï¼š{counters['verifying_to_success']}ï¼‰\n"
            f"  â€¢ æ–°å¢è´¦å˜ï¼š{counters['ledger_add']}ï¼Œæœ¬è½®è¿‡æœŸå…³é—­ï¼š{counters['expired_to_closed']}ï¼Œç”¨æ—¶ï¼š{dur:.2f}s"
        )

    finally:
        await close_pool()


if __name__ == "__main__":
    asyncio.run(main_once())


=== src/config.py ===
import os

from dotenv import load_dotenv

load_dotenv()

BOT_TOKEN = os.getenv("BOT_TOKEN", "")
MYSQL_HOST = os.getenv("MYSQL_HOST", "127.0.0.1")
MYSQL_PORT = int(os.getenv("MYSQL_PORT", "3306"))
MYSQL_USER = os.getenv("MYSQL_USER", "hb_user")
MYSQL_PASSWORD = os.getenv("MYSQL_PASSWORD", "hb_pass")
MYSQL_DB = os.getenv("MYSQL_DB", "hb_db")

FERNET_KEY = os.getenv("FERNET_KEY", "")

# TRON / TronGrid / USDT
USDT_CONTRACT = os.getenv("USDT_CONTRACT", "")
AGGREGATE_ADDRESS = os.getenv("AGGREGATE_ADDRESS", "")
TRON_FULLNODE_URL = os.getenv("TRON_FULLNODE_URL", "https://api.trongrid.io")
TRONGRID_API_KEY = os.getenv("TRONGRID_API_KEY", "")  # é€—å·åˆ†éš”å¯é…ç½®å¤šä¸ªï¼Œç”¨äºè½®è¯¢
TRONGRID_QPS = float(
    os.getenv("TRONGRID_QPS", "10")
)  # é¢‘ç‡é™åˆ¶ï¼Œé»˜è®¤ 10 QPSï¼ˆå®˜æ–¹å»ºè®®å¸¦ key å¯è¾¾ ~15 QPSï¼‰
USDT_DECIMALS = int(os.getenv("USDT_DECIMALS", "6"))

# trongas èƒ½é‡ç§Ÿç”¨
TRONGAS_API_KEY = os.getenv("TRONGAS_API_KEY", "")

# ä¸šåŠ¡é…ç½®
MIN_DEPOSIT_USDT = float(os.getenv("MIN_DEPOSIT_USDT", "10"))
MIN_WITHDRAW_USDT = float(os.getenv("MIN_WITHDRAW_USDT", "5"))
WITHDRAW_FEE_FIXED = float(os.getenv("WITHDRAW_FEE_FIXED", "1"))
SUPPORT_CONTACT = os.getenv("SUPPORT_CONTACT", "@support")

# åŸºç¡€æ–­è¨€
assert BOT_TOKEN, "è¯·åœ¨ .env ä¸­é…ç½® BOT_TOKEN"
assert FERNET_KEY, "è¯·åœ¨ .env ä¸­é…ç½® FERNET_KEY"
assert USDT_CONTRACT, "è¯·åœ¨ .env ä¸­é…ç½® USDT_CONTRACTï¼ˆTRC20 USDT åˆçº¦åœ°å€ï¼‰"
assert AGGREGATE_ADDRESS, "è¯·åœ¨ .env ä¸­é…ç½® AGGREGATE_ADDRESSï¼ˆå½’é›†æ”¶æ¬¾åœ°å€ï¼‰"


=== src/db.py ===
from typing import Any, Dict, List, Optional, Tuple

import aiomysql

from .config import MYSQL_DB, MYSQL_HOST, MYSQL_PASSWORD, MYSQL_PORT, MYSQL_USER
from .logger import app_logger

_pool: Optional[aiomysql.Pool] = None


async def init_pool():
    global _pool
    if _pool is None:
        _pool = await aiomysql.create_pool(
            host=MYSQL_HOST,
            port=MYSQL_PORT,
            user=MYSQL_USER,
            password=MYSQL_PASSWORD,
            db=MYSQL_DB,
            autocommit=True,
            minsize=1,
            maxsize=10,
            charset="utf8mb4",
        )
        app_logger.info("âœ… MySQL è¿æ¥æ± å·²åˆå§‹åŒ–")


async def close_pool():
    global _pool
    if _pool is not None:
        _pool.close()
        await _pool.wait_closed()
        _pool = None
        app_logger.info("ğŸ›‘ MySQL è¿æ¥æ± å·²å…³é—­")


async def get_conn():
    assert _pool is not None, "MySQL è¿æ¥æ± æœªåˆå§‹åŒ–"
    return _pool.acquire()


async def fetchone(sql: str, args: Tuple = ()) -> Optional[Dict[str, Any]]:
    async with await get_conn() as conn:
        async with conn.cursor(aiomysql.DictCursor) as cur:
            await cur.execute(sql, args)
            return await cur.fetchone()


async def fetchall(sql: str, args: Tuple = ()) -> List[Dict[str, Any]]:
    async with await get_conn() as conn:
        async with conn.cursor(aiomysql.DictCursor) as cur:
            await cur.execute(sql, args)
            return await cur.fetchall()


async def execute(sql: str, args: Tuple = ()) -> int:
    async with await get_conn() as conn:
        async with conn.cursor() as cur:
            await cur.execute(sql, args)
            return cur.lastrowid or 0


=== src/handlers/address_book.py ===
from telegram import Update
from telegram.ext import ContextTypes

from ..logger import address_logger
from ..models import add_user_address, list_user_addresses
from ..services.tron import is_valid_address

ALIA_MAX = 15

TIPS = (
    'âš ï¸ è¯·ä¾ç…§"åœ°å€ åˆ«å"ï¼Œä¸¤è€…ä¹‹é—´è¯·ç”¨ç©ºæ ¼éš”å¼€ï¼Œæ·»åŠ åœ°å€åŠå…¶åˆ«åï¼ å¦‚ :\n'
    'TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t IM-ä¸ªäºº\n\nå‘é€ "åˆ—è¡¨" æŸ¥çœ‹å·²æœ‰åœ°å€ã€‚'
)


async def address_entry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (update.message.text or "").strip()
    if text in ("åˆ—è¡¨", "list", "æŸ¥çœ‹"):
        rows = await list_user_addresses(update.effective_user.id)
        if not rows:
            await update.message.reply_text("æš‚æ— å¸¸ç”¨åœ°å€ã€‚\n" + TIPS)
            return
        lines = ["å¸¸ç”¨åœ°å€åˆ—è¡¨ï¼š"]
        for r in rows:
            lines.append(f"- {r['alias']}: {r['address']}")
        await update.message.reply_text("\n".join(lines))
        return

    parts = text.split()
    if len(parts) < 2:
        await update.message.reply_text("æ ¼å¼ä¸æ­£ç¡®ã€‚\n" + TIPS)
        return
    addr, alias = parts[0], " ".join(parts[1:])
    if len(alias) > ALIA_MAX:
        await update.message.reply_text(f"åˆ«åè¿‡é•¿ï¼ˆ>{ALIA_MAX}ï¼‰ï¼Œè¯·é‡æ–°è¾“å…¥ã€‚")
        return
    if not is_valid_address(addr):
        await update.message.reply_text("TRX åœ°å€æ ¼å¼ä¸æ­£ç¡®ï¼Œè¯·æ£€æŸ¥åé‡è¯•ã€‚")
        return

    await add_user_address(update.effective_user.id, addr, alias)
    address_logger.info(
        f"ğŸ“® ç”¨æˆ· {update.effective_user.id} ç»‘å®šåœ°å€ï¼š{addr}ï¼ˆ{alias}ï¼‰"
    )
    await update.message.reply_text('åœ°å€ç»‘å®šæˆåŠŸï¼å‘é€ "åˆ—è¡¨" å¯æŸ¥çœ‹ã€‚')


=== src/handlers/addr_query.py ===
from telegram import Update
from telegram.ext import ContextTypes

from ..config import USDT_CONTRACT
from ..services.tron import (
    get_account_resource,
    get_recent_transfers,
    get_trc20_balance,
    get_trx_balance,
    is_valid_address,
)
from .common import fmt_amount, show_main_menu


async def addr_query(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("è¯·å‘é€è¦æ ¡éªŒçš„ TRON åœ°å€ï¼š")
    context.user_data["addr_query_waiting"] = True


async def addr_query_ontext(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not context.user_data.pop("addr_query_waiting", False):
        return
    addr = (update.message.text or "").strip()
    ok = is_valid_address(addr)
    await update.message.reply_text(
        f"åœ°å€ {addr} æ ¡éªŒç»“æœï¼š{'âœ…æœ‰æ•ˆ' if ok else 'âŒæ— æ•ˆ'}ã€‚\nï¼ˆé“¾ä¸Šä½™é¢æŸ¥è¯¢åç»­æ¥å…¥ï¼‰"
    )


async def on_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (update.message.text or "").strip()
    addr = text.split()[0]

    if not is_valid_address(addr):
        await update.message.reply_text("å½“å‰ä»…æ”¯æŒ TRC-20 æ ¼å¼åœ°å€ï¼Œè¯·é‡æ–°è¾“å…¥")
        await show_main_menu(update.effective_chat.id, context)
        return

    trx = await get_trx_balance(addr)
    usdt = await get_trc20_balance(addr, USDT_CONTRACT)
    res = get_account_resource(addr)
    transfers = await get_recent_transfers(addr, limit=10)

    lines = [
        f"ğŸ“® åœ°å€ï¼š`{addr}`",
        f"TRXï¼š{fmt_amount(trx)}",
        f"USDTï¼š{fmt_amount(usdt)}",
        f"å¸¦å®½ï¼š{res.bandwidth} / èƒ½é‡ï¼š{res.energy}",
        "",
    ]
    if transfers:
        lines.append("ğŸ§¾ æœ€è¿‘ 10 ç¬”è½¬è´¦ï¼ˆç®€è¦ï¼‰ï¼š")
        for t in transfers:
            direction = "â†—ï¸ æ”¶" if t["to"].lower() == addr.lower() else "â†˜ï¸ ä»˜"
            asset = t.get("asset", "USDT")
            amt = fmt_amount(t["amount"])
            lines.append(f"{direction} {asset} {amt}  {t['hash'][:10]}â€¦")
    else:
        lines.append("ï¼ˆæ— æœ€è¿‘è½¬è´¦ï¼‰")

    await update.message.reply_markdown("\n".join(lines))
    await show_main_menu(update.effective_chat.id, context)


=== src/handlers/common.py ===
from telegram import Update
from telegram.ext import ContextTypes

from ..keyboards import MAIN_MENU
from ..logger import app_logger, user_click_logger
from ..models import ensure_user, get_wallet, set_tron_wallet
from ..services.encryption import encrypt_text
from ..services.tron import generate_address


def fmt_amount(x) -> str:
    try:
        return f"{float(x):.2f}"
    except Exception:
        return str(x)


async def ensure_user_and_wallet(update: Update, context: ContextTypes.DEFAULT_TYPE):
    u = update.effective_user
    await ensure_user(u.id, u.username, u.first_name, u.last_name)
    wallet = await get_wallet(u.id)
    if not wallet or not wallet.get("tron_address"):
        addr = generate_address()
        await set_tron_wallet(u.id, addr.address, encrypt_text(addr.private_key_hex))
        app_logger.info(f"ğŸ” ä¸ºç”¨æˆ· {u.id} ç”Ÿæˆ TRON åœ°å€: {addr.address}")
    user_click_logger.info(
        f"ğŸ‘† ç”¨æˆ· {u.id} è§¦å‘äº¤äº’ï¼š{update.effective_message.text if update.effective_message else 'callback'}"
    )


async def show_main_menu(chat_id: int, context: ContextTypes.DEFAULT_TYPE):
    await context.bot.send_message(chat_id, "â¬‡ï¸ ä¸»èœå•", reply_markup=MAIN_MENU)


async def end_and_menu(update, context):
    """ä¾¿æ·ï¼šåœ¨æŸäº› handler é‡Œç»“æŸåç›´æ¥è°ƒç”¨"""
    await show_main_menu(update.effective_chat.id, context)


=== src/handlers/fx.py ===
from telegram import Update
from telegram.ext import ContextTypes


# å ä½ï¼šå¯å¯¹æ¥ç¬¬ä¸‰æ–¹è¡Œæƒ…ï¼ˆå¦‚ CoinGecko / Binance APIï¼‰
async def show_fx(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "æ±‡ç‡æŸ¥è¯¢å ä½ï¼šUSDTâ‰ˆ1 USDï¼›å¯åœ¨æ­¤æ¥å…¥ç¬¬ä¸‰æ–¹è¡Œæƒ…æ¥å£ã€‚"
    )


=== src/handlers/ledger.py ===
from telegram import Update
from telegram.ext import ContextTypes

from ..models import list_ledger_recent
from .common import fmt_amount


async def show_ledger(update: Update, context: ContextTypes.DEFAULT_TYPE):
    u = update.effective_user
    rows = await list_ledger_recent(u.id, 10)
    if not rows:
        await update.message.reply_text("æš‚æ— è´¦å˜è®°å½•ã€‚")
        return
    lines = ["æœ€è¿‘10ç¬”è´¦å˜ï¼š"]
    for r in rows:
        lines.append(
            f"[{r['created_at']}] {r['change_type']} é‡‘é¢:{fmt_amount(r['amount'])} ä½™é¢:{fmt_amount(r['balance_after'])} å¤‡æ³¨:{r.get('remark') or ''}"
        )
    await update.message.reply_text("\n".join(lines))


=== src/handlers/password.py ===
# src/handlers/password.py
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import ContextTypes

from ..models import has_tx_password, set_tx_password_hash
from ..services.encryption import hash_password
from .common import show_main_menu


def _kb(masked=True):
    # 0-9 ä¹å®«æ ¼ + å–æ¶ˆ + æ˜¾ç¤º/éšè—
    rows = []
    nums = ["0", "1", "4", "6", "9", "2", "7", "3", "5", "8"]
    for i in range(0, 9, 3):
        rows.append(
            [
                InlineKeyboardButton(nums[i + j], callback_data=f"pwd:{nums[i+j]}")
                for j in range(3)
            ]
        )
    rows.append(
        [
            InlineKeyboardButton("å–æ¶ˆ", callback_data="pwd:back"),
            InlineKeyboardButton("0", callback_data="pwd:0"),
            InlineKeyboardButton("ğŸ‘" if masked else "ğŸ™ˆ", callback_data="pwd:vis"),
        ]
    )
    rows.append([InlineKeyboardButton("ç¡®å®š", callback_data="pwd:ok")])
    return InlineKeyboardMarkup(rows)


async def start_set_password(update: Update, context: ContextTypes.DEFAULT_TYPE):
    u = update.effective_user
    context.user_data["pwd_buf"] = ""
    context.user_data["pwd_mask"] = True
    existed = await has_tx_password(u.id)
    title = "ä¿®æ”¹äº¤æ˜“å¯†ç " if existed else "è®¾ç½®äº¤æ˜“å¯†ç "
    hint = "è¯·è¾“å…¥æ–°äº¤æ˜“å¯†ç ï¼ˆ4~6ä½æ•°å­—ï¼‰"
    await update.message.reply_text(
        f"ğŸ›  {title}\n{hint}\n\nğŸ”‘ " + "â€¢" * 0, reply_markup=_kb(True)
    )


async def password_kb_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    data = (q.data or "").split(":")[1]
    buf = context.user_data.get("pwd_buf", "")
    masked = context.user_data.get("pwd_mask", True)

    if data == "back":
        await q.edit_message_text("å·²å–æ¶ˆè®¾ç½®ã€‚")
        await show_main_menu(q.message.chat_id, context)
        return
    if data == "vis":
        masked = not masked
        context.user_data["pwd_mask"] = masked
        disp = "â€¢" * len(buf) if masked else buf
        await q.edit_message_text(
            f"ğŸ›  è®¾ç½®äº¤æ˜“å¯†ç \n\nğŸ”‘ {disp}", reply_markup=_kb(masked)
        )
        return
    if data == "ok":
        if len(buf) < 4 or len(buf) > 6:
            await q.answer("è¯·è¾“å…¥4~6ä½æ•°å­—", show_alert=True)
            return
        u = q.from_user
        await set_tx_password_hash(u.id, hash_password(buf))
        await q.edit_message_text("âœ… äº¤æ˜“å¯†ç è®¾ç½®æˆåŠŸ")
        await show_main_menu(q.message.chat_id, context)
        return

    # æ•°æ®æ˜¯æ•°å­—
    if len(buf) >= 6:
        await q.answer("æœ€å¤š6ä½æ•°å­—", show_alert=True)
        return
    buf += data
    context.user_data["pwd_buf"] = buf
    disp = "â€¢" * len(buf) if masked else buf
    await q.edit_message_text(f"ğŸ›  è®¾ç½®äº¤æ˜“å¯†ç \n\nğŸ”‘ {disp}", reply_markup=_kb(masked))


=== src/handlers/recharge.py ===
from datetime import datetime, timedelta
from io import BytesIO

from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import ContextTypes

from ..config import MIN_DEPOSIT_USDT
from ..logger import recharge_logger
from ..models import (
    create_recharge_order,
    get_ledger_amount_by_ref,
    get_recharge_order,
    get_user_balance,
    get_wallet,
)
from ..services.qrcode_util import make_qr_png_bytes
from .common import fmt_amount, show_main_menu


def _fmt_code(s: str, tail: str = "ğŸ‘ˆ ç‚¹å‡»å¤åˆ¶") -> str:
    # Telegram CODE æ ¼å¼ + ä¸¤ä¸ªç©ºæ ¼ + å·¦æŒ‡å°æ‰‹ + ç‚¹å‡»å¤åˆ¶
    return f"`{s}`  ğŸ‘ˆ {tail}"


async def show_recharge(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ç‚¹å‡»ã€å……å€¼ã€‘â€”â€”ç›´æ¥å¼¹å‡ºäºŒç»´ç â€œå›¾ç‰‡æŸ¥çœ‹å™¨â€+å¸¦è¯´æ˜çš„ captionã€‚"""
    u = update.effective_user
    wallet = await get_wallet(u.id)
    addr = wallet.get("tron_address") if wallet else "-"

    # è‹¥å·²æœ‰æœªè¿‡æœŸè®¢å•ï¼Œå¤ç”¨ï¼›å¦åˆ™ç”Ÿæˆæ–°å•ï¼ˆæœ‰æ•ˆæœŸ 15 åˆ†é’Ÿï¼‰
    order_id = await create_recharge_order(u.id, addr, None, 15)

    # äºŒç»´ç ï¼šç¼©å° 50%ï¼ŒåŒæ—¶æŠŠåœ°å€å†™åœ¨å›¾ç‰‡ä¸‹æ–¹ï¼ˆå›¾ä¸Šå¯è§ï¼‰
    caption_text = f"TRX/USDT-trc20 ONLY\n\n{addr}"
    png_bytes = make_qr_png_bytes(addr, scale=0.5, caption=caption_text)
    bio = BytesIO(png_bytes)
    bio.name = "recharge_qr.png"

    expire_at = (datetime.now() + timedelta(minutes=15)).strftime("%Y-%m-%d %H:%M:%S")
    human = (
        "âš ï¸ å……å€¼é‡‘é¢ **{minu} USDT** èµ·ï¼›\n"
        "â± è®¢å•åˆ°æœŸï¼š{exp}ï¼ˆå‰©ä½™15åˆ†é’Ÿï¼‰ï¼›\n"
        "ğŸ’¡ å……å€¼åè¯·è€å¿ƒç­‰å¾…ï¼Œåˆ°è´¦ä¼šè‡ªåŠ¨é€šçŸ¥ã€‚"
    ).format(minu=fmt_amount(MIN_DEPOSIT_USDT), exp=expire_at)

    # åœ°å€/è®¢å•å·ä½¿ç”¨ CODE æ ·å¼ï¼›åœ°å€è¡Œæœ«æ˜¾ç¤ºâ€œğŸ‘ˆ ç‚¹å‡»å¤åˆ¶â€
    cap = (
        f"ğŸ§¾ **å……å€¼ä¿¡æ¯**\n"
        f"æ”¶æ¬¾ç½‘ç»œï¼šUSDT-TRC20\n\n"
        f"æ”¶æ¬¾åœ°å€ï¼š{_fmt_code(addr)}\n"
        f"è®¢å•å·ï¼š{_fmt_code(str(order_id))}\n\n"
        f"{human}"
    )

    kb = InlineKeyboardMarkup(
        [  # æŒ‰é’®åœ¨æ–‡æœ¬ä¸‹
            [
                InlineKeyboardButton(
                    "ğŸ“‹ å¤åˆ¶åœ°å€", callback_data=f"recharge_copy:{order_id}"
                )
            ],
            [
                InlineKeyboardButton(
                    "ğŸ”„ åˆ·æ–°çŠ¶æ€", callback_data=f"recharge_status:{order_id}"
                )
            ],
            [InlineKeyboardButton("â¬…ï¸ è¿”å›ä¸»èœå•", callback_data="back_to_menu")],
        ]
    )

    await update.message.reply_photo(
        photo=bio, caption=cap, reply_markup=kb, parse_mode="Markdown"
    )
    recharge_logger.info(f"ğŸ§¾ ç”¨æˆ· {u.id} ä½¿ç”¨å……å€¼è®¢å• {order_id}ï¼Œåœ°å€ {addr}")


async def recharge_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    data = q.data or ""
    u = q.from_user

    if data == "back_to_menu":
        await q.message.reply_text("å·²è¿”å›ä¸»èœå•ã€‚")
        await show_main_menu(q.message.chat_id, context)
        return

    if data.startswith("recharge_copy:"):
        wallet = await get_wallet(u.id)
        addr = wallet.get("tron_address") if wallet else "-"
        # å¼¹çª—æ˜¾ç¤ºï¼Œç”¨æˆ·å¯é•¿æŒ‰å¤åˆ¶
        await q.answer(text=addr, show_alert=True)
        return

    if data.startswith("recharge_status:"):
        try:
            oid = int(data.split(":")[1])
        except Exception:
            await q.answer("è®¢å•å·ä¸åˆæ³•", show_alert=True)
            return

        order = await get_recharge_order(oid)
        if not order:
            await q.answer("è®¢å•ä¸å­˜åœ¨æˆ–å·²è¿‡æœŸ", show_alert=True)
            return

        display = {
            "waiting": "ç­‰å¾…ç”¨æˆ·è½¬è´¦",
            "collecting": "å¾…å½’é›†",
            "verifying": "éªŒè¯ä¸­",
            "success": "å……å€¼æˆåŠŸ",
            "expired": "å·²è¿‡æœŸ",
            "failed": "å¤±è´¥",
        }
        st = order["status"]
        lines = [
            f"ğŸ§¾ è®¢å•å·ï¼š`{order['id']}`",
            f"çŠ¶æ€ï¼š{display.get(st, st)}",
        ]
        if st == "success":
            # æŸ¥è¯¢æœ¬å•å……å€¼åˆ°è´¦é‡‘é¢ï¼ˆä»è´¦å˜é‡ŒæŒ‰ ref æ‰¾ï¼‰
            amt = await get_ledger_amount_by_ref(
                user_id=order["user_id"],
                ref_type="recharge",
                ref_table="recharge_orders",
                ref_id=order["id"],
            )
            bal = await get_user_balance(order["user_id"])
            if amt is not None:
                lines.append(f"åˆ°è´¦é‡‘é¢ï¼š**{fmt_amount(amt)} USDT**")
            lines.append(f"å½“å‰ä½™é¢ï¼š**{fmt_amount(bal)} USDT**")
            lines.append("âœ… å……å€¼æˆåŠŸï¼Œç¥æ‚¨ä½¿ç”¨æ„‰å¿«ï¼")

            await q.message.reply_markdown("\n".join(lines))
            # ç»“æŸåé‡ç°ä¸»èœå•
            await show_main_menu(q.message.chat_id, context)
            return

        # å…¶ä»–çŠ¶æ€ï¼Œä»…å±•ç¤ºæ–‡æ¡ˆ
        await q.message.reply_markdown("\n".join(lines))
        # ç»™ä¸ªè¿”å›ä¸»èœå•
        await show_main_menu(q.message.chat_id, context)


=== src/handlers/red_packet.py ===
from decimal import Decimal

from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import ContextTypes

from ..handlers.common import ensure_user_and_wallet, fmt_amount
from ..keyboards import redpacket_create_menu
from ..models import (
    add_ledger,
    claim_share,
    count_claimed,
    create_red_packet,
    execute,
    get_red_packet,
    get_wallet,
    list_red_packet_shares,
    list_red_packets,
    save_red_packet_share,
    set_red_packet_status,
    update_wallet_balance,
)
from ..services.redalgo import split_average, split_random
from .common import show_main_menu

TYPES = [("random", "ğŸ² éšæœº"), ("avg", "ğŸ“¦ å¹³å‡"), ("exclusive", "ğŸ”’ ä¸“å±")]


def _kb(cur: str):
    row = []
    for k, label in TYPES:
        prefix = "âœ… " if k == cur else ""
        row.append(InlineKeyboardButton(prefix + label, callback_data=f"rp_type:{k}"))
    return InlineKeyboardMarkup([row])


def _render(cur: str) -> str:
    pretty = " | ".join([("ğŸ‘‰" + l) if k == cur else l for k, l in TYPES])
    return (
        "ğŸ§§ å‘é€çº¢åŒ…\n\n"
        "å°é¢æœªè®¾ç½®\n\n"
        "--- â˜ï¸ çº¢åŒ…å°é¢ â˜ï¸ ---\n\n"
        f"ç±»å‹ï¼š[ {pretty} ]\n\n"
        "å¸ç§ï¼šUSDT-trc20\næ•°é‡ï¼š1\né‡‘é¢ï¼š1.00\n\n"
        "æç¤ºï¼šæœªé¢†å–çš„å°†åœ¨24å°æ—¶åé€€æ¬¾ã€‚"
    )


def _type_kb(cur: str):
    rows = []
    btns = []
    for k, label in TYPES:
        prefix = "âœ… " if k == cur else ""
        btns.append(InlineKeyboardButton(prefix + label, callback_data=f"rp_type:{k}"))
    rows.append(btns)
    return InlineKeyboardMarkup(rows)


async def entry_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # âœ… åŠŸèƒ½é”
    if await get_flag("lock_redpacket"):
        await update.message.reply_text("âš ï¸ ç»´æŠ¤ä¸­..è¯·ç¨å€™å°è¯•!")
        await show_main_menu(update.effective_chat.id, context)
        return

    cur = context.user_data.get("rp_type", "random")
    context.user_data["rp_type"] = cur
    await update.message.reply_text(_render(cur), reply_markup=_kb(cur))


async def set_rp_type(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    try:
        _, t = (q.data or "rp_type:random").split(":", 1)
    except Exception:
        t = "random"
    if t not in [k for k, _ in TYPES]:
        t = "random"
    context.user_data["rp_type"] = t
    await q.edit_message_text(text=_render(t), reply_markup=_kb(t))


async def type_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    _, t = (q.data or "rp_type:random").split(":", 1)
    if t not in [k for k, _ in TYPES]:
        t = "random"
    context.user_data["rp_type"] = t
    cur = t
    text = (
        "ğŸ§§ å‘é€çº¢åŒ…\n\n"
        "å°é¢æœªè®¾ç½®\n\n"
        "--- â˜ï¸ çº¢åŒ…å°é¢ â˜ï¸ ---\n\n"
        f"ç±»å‹ï¼š[{ 'ã€'.join([('ğŸ‘‰'+l) if k==cur else l for k,l in TYPES]) }]\n\n"
        "å¸ç§ï¼šUSDT-trc20\næ•°é‡ï¼š1\né‡‘é¢ï¼š1.00\n\n"
        "æç¤ºï¼šæœªé¢†å–çš„å°†åœ¨24å°æ—¶åé€€æ¬¾ã€‚"
    )
    await q.edit_message_text(text=text, reply_markup=_type_kb(cur))


def _fmt_rp(r):
    return f"ID:{r['id']} | ç±»å‹:{r['type']} | æ•°é‡:{r['count']} | æ€»é¢:{fmt_amount(r['total_amount'])} | çŠ¶æ€:{r['status']}"


async def show_red_packets(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await ensure_user_and_wallet(update, context)
    u = update.effective_user
    recs = await list_red_packets(u.id, 10)
    lines = ["ğŸ§§ æœ€è¿‘çº¢åŒ…è®°å½•ï¼ˆæœ€å¤š10æ¡ï¼‰ï¼š"]
    if recs:
        lines += [_fmt_rp(r) for r in recs]
    else:
        lines.append("ï¼ˆæš‚æ— ï¼‰")
    kb = InlineKeyboardMarkup(
        [
            [InlineKeyboardButton("æ ¹æ®IDæŸ¥çœ‹è¯¦æƒ…", callback_data="rp_query:ask")],
            [InlineKeyboardButton("â• åˆ›å»ºçº¢åŒ…", callback_data="rp_new")],
        ]
    )
    await update.message.reply_text("\n".join(lines), reply_markup=kb)


async def rp_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    data = q.data or ""
    u = update.effective_user

    if data == "rp_new":
        rp_id = await create_red_packet(u.id, "random", 1.0, 1, None, None, None)
        await q.message.reply_text(
            _compose_create_text("random", 1, 1.0, cover=None),
            reply_markup=redpacket_create_menu(rp_id, "random"),
        )
        return

    if data.startswith("rp_type:"):
        _, rp_id_str, new_type = data.split(":")
        rp_id = int(rp_id_str)
        await execute(
            "UPDATE red_packets SET type=%s, exclusive_user_id=IF(%s='exclusive',exclusive_user_id,NULL) WHERE id=%s",
            (new_type, new_type, rp_id),
        )
        r = await get_red_packet(rp_id)
        await q.message.reply_text(
            _compose_create_text(
                r["type"], r["count"], r["total_amount"], r.get("cover_text")
            ),
            reply_markup=redpacket_create_menu(rp_id, r["type"]),
        )
        return

    if data.startswith("rp_query:ask"):
        context.user_data["rp_query_waiting"] = True
        await q.message.reply_text("è¯·è¾“å…¥çº¢åŒ…IDï¼š")
        return

    if data.startswith("rp_detail:"):
        rp_id = int(data.split(":")[1])
        r = await get_red_packet(rp_id)
        if not r:
            await q.message.reply_text("æœªæ‰¾åˆ°çº¢åŒ…ã€‚")
            return
        shares = await list_red_packet_shares(rp_id)
        claimed = sum(1 for s in shares if s["claimed_by"]) if shares else 0
        await q.message.reply_text(
            f"ğŸ§§ çº¢åŒ…è¯¦æƒ…\nID:{r['id']}\nç±»å‹:{r['type']}\nå¸ç§:{r['currency']}\næ•°é‡:{r['count']}\né‡‘é¢:{fmt_amount(r['total_amount'])}\nå°é¢:{r.get('cover_text') or 'æœªè®¾ç½®'}\nä¸“å±:{r.get('exclusive_user_id') or 'æ— '}\nçŠ¶æ€:{r['status']}\nå·²é¢†:{claimed}/{r['count']}"
        )
        return

    if data.startswith("rp_set_count:"):
        rp_id = int(data.split(":")[1])
        context.user_data["await_field"] = ("count", rp_id)
        await q.message.reply_text("è¯·è¾“å…¥çº¢åŒ…æ•°é‡ï¼ˆæ•´æ•°ï¼‰ï¼š")
        return

    if data.startswith("rp_set_amount:"):
        rp_id = int(data.split(":")[1])
        context.user_data["await_field"] = ("amount", rp_id)
        await q.message.reply_text("è¯·è¾“å…¥çº¢åŒ…æ€»é‡‘é¢ï¼ˆUSDTï¼Œæ”¯æŒå°æ•°ï¼‰ï¼š")
        return

    if data.startswith("rp_set_exclusive:"):
        rp_id = int(data.split(":")[1])
        context.user_data["await_field"] = ("exclusive", rp_id)
        await q.message.reply_text(
            "ğŸ§§ å‘é€çº¢åŒ…\n\nğŸ‘©â€ğŸ’» ç¡®è®¤ä¸“å±çº¢åŒ…é¢†å–äºº!\nè¯·ä½¿ç”¨ä»¥ä¸‹ä»»æ„ä¸€ç§æ–¹å¼é€‰æ‹©ç›®æ ‡:\nAã€ è½¬å‘å¯¹æ–¹ä»»æ„ä¸€æ¡æ–‡å­—æ¶ˆæ¯åˆ°è¿™é‡Œæ¥.\nBã€ å‘é€å¯¹æ–¹çš„è´¦æˆ·IDï¼Œå¦‚ï¼š588726829\nCã€ å‘é€å¯¹æ–¹çš„ç”¨æˆ·åï¼Œå¦‚ï¼š@username"
        )
        return

    if data.startswith("rp_set_cover:"):
        rp_id = int(data.split(":")[1])
        context.user_data["await_field"] = ("cover", rp_id)
        await q.message.reply_text(
            "âœï¸ è®¾ç½®å°é¢\nğŸ‘©â€ğŸ’» è¯·å‘é€ä¸€æ®µæ–‡å­—ï¼ˆâ‰¤150å­—ç¬¦ï¼‰æˆ–å›¾ç‰‡ä½œä¸ºçº¢åŒ…çš„å°é¢ã€‚"
        )
        return

    if data.startswith("rp_pay:"):
        rp_id = int(data.split(":")[1])
        r = await get_red_packet(rp_id)
        if not r:
            await q.message.reply_text("æœªæ‰¾åˆ°çº¢åŒ…ã€‚")
            return
        if r["type"] == "exclusive" and not r.get("exclusive_user_id"):
            await q.message.reply_text("ä¸“å±çº¢åŒ…å¿…é¡»è®¾ç½®ä¸“å±å¯¹è±¡ï¼Œæ— æ³•æ”¯ä»˜ï¼")
            return

        wallet = await get_wallet(u.id)
        bal = Decimal(str(wallet["usdt_trc20_balance"])) if wallet else Decimal("0")
        total = Decimal(str(r["total_amount"]))
        if bal < total:
            await q.message.reply_text("ä½™é¢ä¸è¶³ï¼Œæ— æ³•æ”¯ä»˜ï¼è¯·å…ˆå……å€¼ã€‚")
            return

        new_bal = bal - total
        await update_wallet_balance(u.id, float(new_bal))
        await add_ledger(
            u.id,
            "redpacket_send",
            -float(total),
            float(bal),
            float(new_bal),
            "red_packets",
            rp_id,
            "å‘é€çº¢åŒ…æ‰£æ¬¾",
        )

        if r["type"] == "random":
            shares = split_random(float(total), int(r["count"]))
        else:
            shares = split_average(float(total), int(r["count"]))
        for i, s in enumerate(shares, 1):
            await save_red_packet_share(rp_id, i, float(s))

        await set_red_packet_status(rp_id, "paid")

        cover = r.get("cover_text") or "å°é¢æœªè®¾ç½®"
        type_cn = (
            "éšæœº"
            if r["type"] == "random"
            else ("å¹³å‡" if r["type"] == "average" else "ä¸“å±")
        )
        await q.message.reply_text(
            f"ğŸ§§ å‘é€çº¢åŒ…\n\n{cover}\n\n--- â˜ï¸ çº¢åŒ…å°é¢ â˜ï¸ ---\n\nç±»å‹ï¼š[{type_cn}]ï¼ˆä¸‹æ–¹å¯åˆ‡æ¢ï¼‰\nå¸ç§ï¼šUSDT-trc20\næ•°é‡ï¼š{r['count']}\né‡‘é¢ï¼š{fmt_amount(r['total_amount'])}\n\næç¤ºï¼šæœªé¢†å–çš„å°†åœ¨24å°æ—¶åé€€æ¬¾ã€‚",
            reply_markup=InlineKeyboardMarkup(
                [
                    [
                        InlineKeyboardButton(
                            "ğŸ§§ ç«‹å³é¢†å–", callback_data=f"rp_claim:{rp_id}"
                        )
                    ],
                    [
                        InlineKeyboardButton(
                            "æŸ¥çœ‹è¯¦æƒ…", callback_data=f"rp_detail:{rp_id}"
                        )
                    ],
                ]
            ),
        )
        await set_red_packet_status(rp_id, "sent")
        return

    if data.startswith("rp_claim:"):
        rp_id = int(data.split(":")[1])
        r = await get_red_packet(rp_id)
        if not r or r["status"] not in ("sent", "paid"):
            await q.message.reply_text("çº¢åŒ…ä¸å¯é¢†å–æˆ–ä¸å­˜åœ¨ã€‚")
            return
        if (
            r["type"] == "exclusive"
            and r.get("exclusive_user_id") != update.effective_user.id
        ):
            await q.message.reply_text("ä½ ä¸æ˜¯æˆ‘çš„å®è´,ä½ ä¸èƒ½é¢†å–!")
            return

        share = await claim_share(rp_id, update.effective_user.id)
        if not share:
            await q.message.reply_text("çº¢åŒ…å·²é¢†å®Œã€‚")
            return

        amt = Decimal(str(share["amount"]))
        wallet = await get_wallet(update.effective_user.id)
        before = Decimal(str(wallet["usdt_trc20_balance"])) if wallet else Decimal("0")
        after = before + amt
        await update_wallet_balance(update.effective_user.id, float(after))
        await add_ledger(
            update.effective_user.id,
            "redpacket_claim",
            float(amt),
            float(before),
            float(after),
            "red_packets",
            rp_id,
            "é¢†å–çº¢åŒ…å…¥è´¦",
        )
        try:
            await context.bot.send_message(
                chat_id=update.effective_user.id,
                text=f"çº¢åŒ…åˆ°è´¦ï¼š+{fmt_amount(amt)} USDT-trc20ï¼Œå·²å…¥è´¦ä½™é¢ã€‚",
            )
        except Exception:
            pass
        await q.message.reply_text(f"é¢†å–æˆåŠŸï¼Œé‡‘é¢ï¼š{fmt_amount(amt)} USDT-trc20ï¼")

        claimed = await count_claimed(rp_id)
        if claimed >= int(r["count"]):
            await set_red_packet_status(rp_id, "finished")
        return


async def on_user_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if "await_field" not in context.user_data:
        return
    field, rp_id = context.user_data.pop("await_field")
    text = update.message.text or ""

    r = await get_red_packet(rp_id)
    if not r:
        await update.message.reply_text("çº¢åŒ…ä¸å­˜åœ¨ã€‚")
        return

    curr_type = r["type"]
    curr_count = r["count"]
    curr_amount = r["total_amount"]
    cover = r.get("cover_text") or "æœªè®¾ç½®"

    if field == "count":
        try:
            n = int(text.strip())
            if n <= 0 or n > 1000:
                raise ValueError
            await execute("UPDATE red_packets SET count=%s WHERE id=%s", (n, rp_id))
            curr_count = n
        except Exception:
            await update.message.reply_text("æ•°é‡æ— æ•ˆï¼Œè¯·è¾“å…¥æ­£æ•´æ•°ï¼ˆâ‰¤1000ï¼‰ã€‚")
            return

    elif field == "amount":
        try:
            v = float(text.strip())
            if v <= 0:
                raise ValueError
            await execute(
                "UPDATE red_packets SET total_amount=%s WHERE id=%s", (v, rp_id)
            )
            curr_amount = v
        except Exception:
            await update.message.reply_text("é‡‘é¢æ— æ•ˆï¼Œè¯·è¾“å…¥æ­£æ•°ã€‚")
            return

    elif field == "exclusive":
        target_id = None
        if update.message.forward_from:
            target_id = update.message.forward_from.id
        else:
            s = text.strip()
            if s.startswith("@"):
                await update.message.reply_text(
                    "å·²è®°å½•ç”¨æˆ·åï¼ˆè‹¥æ— æ³•è§£æ IDï¼Œè¯·å¯¹æ–¹å…ˆç§èŠæœ¬æœºå™¨äººä»¥å»ºç«‹æ˜ å°„ï¼‰ã€‚"
                )
                await execute(
                    "UPDATE red_packets SET cover_text=CONCAT(COALESCE(cover_text,''),'ï¼ˆä¸“å±@', %s, 'ï¼‰') WHERE id=%s",
                    (s[1:], rp_id),
                )
            else:
                try:
                    target_id = int(s)
                except Exception:
                    target_id = None
        if target_id:
            await execute(
                "UPDATE red_packets SET exclusive_user_id=%s, type='exclusive' WHERE id=%s",
                (target_id, rp_id),
            )
            curr_type = "exclusive"

    elif field == "cover":
        if update.message.photo:
            file_id = update.message.photo[-1].file_id
            await execute(
                "UPDATE red_packets SET cover_image_file_id=%s WHERE id=%s",
                (file_id, rp_id),
            )
            cover = "[å›¾ç‰‡å°é¢]"
        else:
            s = text.strip()
            if len(s) > 150:
                await update.message.reply_text("æ–‡å­—å°é¢æœ€å¤š150å­—ç¬¦ï¼Œè¯·é‡è¯•ã€‚")
                return
            await execute(
                "UPDATE red_packets SET cover_text=%s WHERE id=%s", (s, rp_id)
            )
            cover = s or "æœªè®¾ç½®"

    await update.message.reply_text(
        _compose_create_text(
            curr_type,
            curr_count,
            curr_amount,
            cover=cover if cover != "æœªè®¾ç½®" else None,
        ),
        reply_markup=redpacket_create_menu(rp_id, curr_type),
    )


def _compose_create_text(rp_type: str, count: int, amount: float, cover=None) -> str:
    type_cn = {"random": "éšæœº", "average": "å¹³å‡", "exclusive": "ä¸“å±"}.get(
        rp_type, "éšæœº"
    )
    cover_line = cover if cover else "å°é¢æœªè®¾ç½®"
    return (
        f"ğŸ§§ å‘é€çº¢åŒ…\n\n{cover_line}\n\n--- â˜ï¸ çº¢åŒ…å°é¢ â˜ï¸ ---\n\n"
        f"ç±»å‹ï¼š[{type_cn}]ï¼ˆä¸‹æ–¹å¯åˆ‡æ¢ï¼šéšæœºï½œå¹³å‡ï½œä¸“å±ï¼‰\n"
        f"å¸ç§ï¼šUSDT-trc20\næ•°é‡ï¼š{count}\né‡‘é¢ï¼š{fmt_amount(amount)}\n\n"
        "æç¤ºï¼šæœªé¢†å–çš„å°†åœ¨24å°æ—¶åé€€æ¬¾ã€‚"
    )


=== src/handlers/start.py ===
from telegram import Update
from telegram.ext import ContextTypes

from ..handlers.common import ensure_user_and_wallet
from ..keyboards import MAIN_MENU

WELCOME = (
    "ğŸ‰ æ¬¢è¿ä½¿ç”¨ *USDT-TRC20 çº¢åŒ…æœºå™¨äºº* ï¼\n\n"
    "æˆ‘å¯ä»¥å¸®ä½ ï¼š\n"
    "â€¢ æŸ¥çœ‹é’±åŒ…ä½™é¢ã€å……å€¼/æç°ã€è´¦å˜æ˜ç»†\n"
    "â€¢ å‘é€çº¢åŒ…ï¼ˆéšæœºï½œå¹³å‡ï½œä¸“å±ï¼‰ï¼Œç¾¤å†…ä¸€é”®é¢†å–\n"
    "â€¢ ç»‘å®šå¸¸ç”¨åœ°å€ï¼Œå¿«æ·æç°\n"
    "â€¢ æ±‡ç‡æŸ¥è¯¢ & åœ°å€æœ‰æ•ˆæ€§æ ¡éªŒ\n"
    "â€¢ è®¾ç½®/ä¿®æ”¹äº¤æ˜“å¯†ç \n\n"
    "ğŸ‘‡ è¯·é€‰æ‹©ä¸‹æ–¹èœå•å¼€å§‹ä½“éªŒã€‚"
)


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await ensure_user_and_wallet(update, context)
    await update.message.reply_text(
        WELCOME, reply_markup=MAIN_MENU, parse_mode="Markdown"
    )


=== src/handlers/support.py ===
from telegram import Update
from telegram.ext import ContextTypes

from ..config import SUPPORT_CONTACT


async def show_support(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(f"è”ç³»å®¢æœï¼š{SUPPORT_CONTACT}")


=== src/handlers/wallet.py ===
# src/handlers/wallet.py
from telegram import Update
from telegram.ext import ContextTypes

from ..models import get_or_create_user, get_user_balance
from .common import fmt_amount, show_main_menu


async def my_wallet(update: Update, context: ContextTypes.DEFAULT_TYPE):
    u = update.effective_user
    user = await get_or_create_user(u.id, u.username or "")
    bal = await get_user_balance(user["id"])
    text = (
        f"ğŸ‘¤ è´¦æˆ·IDï¼š{user['tg_id']}\n\n"
        f"ğŸ’° è´¦æˆ·ä½™é¢ï¼š\n"
        f"â€¢ USDT-TRC20ï¼š{fmt_amount(bal)}"
    )
    await update.message.reply_text(text)
    await show_main_menu(update.effective_chat.id, context)


async def help_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    txt = (
        "æ¬¢è¿ä½¿ç”¨ USDT-TRC20 çº¢åŒ…æœºå™¨äººï¼š\n"
        "â€¢ æˆ‘çš„é’±åŒ…ï¼šä½™é¢/èµ„é‡‘æ˜ç»†\n"
        "â€¢ å……å€¼ï¼šç”Ÿæˆè®¢å•ï¼Œæ‰«ç æˆ–å¤åˆ¶åœ°å€\n"
        "â€¢ æç°ï¼šç»‘å®šå¸¸ç”¨åœ°å€åç”³è¯·\n"
        "â€¢ çº¢åŒ…ï¼šéšæœº/å¹³å‡/ä¸“å± ç±»å‹å‘é€\n"
        "â€¢ è®¾ç½®å¯†ç ï¼šä¹å®«æ ¼è¾“å…¥ï¼Œèµ„é‡‘æ“ä½œäºŒæ¬¡æ ¡éªŒ"
    )
    await update.message.reply_text(txt)
    await show_main_menu(update.effective_chat.id, context)


=== src/handlers/withdraw.py ===
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import ContextTypes

from ..config import MIN_WITHDRAW_USDT, WITHDRAW_FEE_FIXED
from ..logger import withdraw_logger
from ..models import get_flag, get_wallet, list_user_addresses
from .common import fmt_amount, show_main_menu


async def withdraw_entry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # âœ… åŠŸèƒ½é”æ‹¦æˆªå¿…é¡»å†™åœ¨å¼‚æ­¥å‡½æ•°å†…éƒ¨
    if await get_flag("lock_withdraw"):
        await update.message.reply_text("âš ï¸ ç»´æŠ¤ä¸­..è¯·ç¨å€™å°è¯•!")
        await show_main_menu(update.effective_chat.id, context)
        return

    # TODO: è¿™é‡Œç»§ç»­ä½ çš„æç°æµç¨‹ï¼ˆä½™é¢ã€åœ°å€åˆ—è¡¨ã€æ‰‹ç»­è´¹è¯´æ˜ç­‰ï¼‰
    await update.message.reply_text("æç°åŠŸèƒ½å¼€å‘ä¸­â€¦")
    await show_main_menu(update.effective_chat.id, context)


async def show_withdraw(update: Update, context: ContextTypes.DEFAULT_TYPE):
    u = update.effective_user
    wallet = await get_wallet(u.id)
    bal = wallet["usdt_trc20_balance"] if wallet else 0.0
    text = (
        f"è´¦æˆ·IDï¼š\n{u.id}\n\nUSDT-trc20 -- å½“å‰ä½™é¢: {fmt_amount(bal)} U\n"
        f"æç¤º: æœ€å°ææ¬¾é‡‘é¢: {fmt_amount(MIN_WITHDRAW_USDT)} U\næ‰‹ç»­è´¹: 0% + {fmt_amount(WITHDRAW_FEE_FIXED)} U\n"
    )
    if float(bal) < MIN_WITHDRAW_USDT + WITHDRAW_FEE_FIXED:
        text += "\nä½™é¢ä¸è¶³æç°æœ€ä½è¦æ±‚!"
        await update.message.reply_text(text)
        return

    addrs = await list_user_addresses(u.id)
    if not addrs:
        kb = InlineKeyboardMarkup(
            [[InlineKeyboardButton("æ·»åŠ åœ°å€", callback_data="addr_add_start")]]
        )
        await update.message.reply_text(
            text + "\næ— å¸¸ç”¨é’±åŒ…åœ°å€,è¯·æ·»åŠ ç»‘å®š:", reply_markup=kb
        )
        return

    lines = [text, "\nå·²æ·»åŠ å¸¸ç”¨åœ°å€ï¼š"]
    btns = []
    for a in addrs:
        lines.append(f"- {a['alias']}  {a['address']}")
        btns.append(
            [
                InlineKeyboardButton(
                    f"æåˆ° {a['alias']}", callback_data=f"withdraw_to:{a['id']}"
                )
            ]
        )
    await update.message.reply_text(
        "\n".join(lines), reply_markup=InlineKeyboardMarkup(btns)
    )


async def withdraw_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    data = q.data or ""
    if data.startswith("withdraw_to:"):
        await q.message.reply_text(
            "æç°åŠŸèƒ½å ä½ï¼šå°†è¿›è¡Œäº¤æ˜“å¯†ç æ ¡éªŒä¸é“¾ä¸Šè½¬è´¦ï¼Œåç»­å®Œå–„ã€‚"
        )
        withdraw_logger.info(f"ğŸ“¤ æç°å ä½ï¼šäº‹ä»¶ {data}")


=== src/keyboards.py ===
from telegram import (
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    KeyboardButton,
    ReplyKeyboardMarkup,
)

MAIN_MENU = ReplyKeyboardMarkup(
    [
        [KeyboardButton("ğŸ’° æˆ‘çš„é’±åŒ…")],
        [KeyboardButton("ğŸ’± æ±‡ç‡æŸ¥è¯¢"), KeyboardButton("ğŸ§­ åœ°å€æŸ¥è¯¢")],
        [KeyboardButton("ğŸ†˜ è”ç³»å®¢æœ"), KeyboardButton("ğŸ” è®¾ç½®å¯†ç /ä¿®æ”¹å¯†ç ")],
    ],
    resize_keyboard=True,
)

WALLET_MENU = ReplyKeyboardMarkup(
    [
        [KeyboardButton("ğŸ§§ çº¢åŒ…"), KeyboardButton("â• å……å€¼")],
        [KeyboardButton("ğŸ’¸ æç°"), KeyboardButton("ğŸ“’ èµ„é‡‘æ˜ç»†")],
        [KeyboardButton("ğŸ“ å¸¸ç”¨åœ°å€")],
        [KeyboardButton("â¬…ï¸ è¿”å›ä¸»èœå•")],
    ],
    resize_keyboard=True,
)


def redpacket_inline_menu(rp_id: int):
    return InlineKeyboardMarkup(
        [
            [InlineKeyboardButton("ğŸ§§ ç«‹å³é¢†å–", callback_data=f"rp_claim:{rp_id}")],
            [InlineKeyboardButton("æŸ¥çœ‹è¯¦æƒ…", callback_data=f"rp_detail:{rp_id}")],
        ]
    )


def _type_row(rp_id: int, rp_type: str):
    def _btn(t, label):
        hand = "ğŸ‘‰ " if t == rp_type else ""
        return InlineKeyboardButton(
            f"{hand}{label}", callback_data=f"rp_type:{rp_id}:{t}"
        )

    return [
        _btn("random", "éšæœº"),
        _btn("average", "å¹³å‡"),
        _btn("exclusive", "ä¸“å±"),
    ]


def redpacket_create_menu(rp_id: int, rp_type: str):
    if rp_type in ("random", "average"):
        row1 = [
            InlineKeyboardButton("è®¾ç½®çº¢åŒ…æ•°é‡", callback_data=f"rp_set_count:{rp_id}"),
            InlineKeyboardButton(
                "è®¾ç½®çº¢åŒ…é‡‘é¢", callback_data=f"rp_set_amount:{rp_id}"
            ),
        ]
    else:  # exclusive
        row1 = [
            InlineKeyboardButton(
                "è®¾ç½®ä¸“å±å¯¹è±¡", callback_data=f"rp_set_exclusive:{rp_id}"
            ),
            InlineKeyboardButton(
                "è®¾ç½®çº¢åŒ…é‡‘é¢", callback_data=f"rp_set_amount:{rp_id}"
            ),
        ]
    row2 = [
        InlineKeyboardButton("è®¾ç½®å°é¢", callback_data=f"rp_set_cover:{rp_id}"),
        InlineKeyboardButton("ç¡®è®¤æ”¯ä»˜", callback_data=f"rp_pay:{rp_id}"),
    ]
    return InlineKeyboardMarkup([_type_row(rp_id, rp_type), row1, row2])


=== src/logger.py ===
import logging
import os
from logging.handlers import RotatingFileHandler

LOG_DIR = os.path.join(os.getcwd(), "logs")
os.makedirs(LOG_DIR, exist_ok=True)


def _make_handler(filename: str) -> RotatingFileHandler:
    handler = RotatingFileHandler(
        os.path.join(LOG_DIR, filename),
        maxBytes=5 * 1024 * 1024,
        backupCount=5,
        encoding="utf-8",
    )
    fmt = logging.Formatter("%(asctime)s [%(levelname)s] %(name)s: %(message)s")
    handler.setFormatter(fmt)
    return handler


def get_logger(name: str) -> logging.Logger:
    logger = logging.getLogger(name)
    if not logger.handlers:
        logger.setLevel(logging.INFO)
        sh = logging.StreamHandler()
        sh.setFormatter(
            logging.Formatter("%(asctime)s [%(levelname)s] %(name)s: %(message)s")
        )
        logger.addHandler(sh)
        mapping = {
            "recharge": "recharge.log",
            "redpacket": "redpacket.log",
            "user_click": "user_click.log",
            "withdraw": "withdraw.log",
            "password": "password.log",
            "address": "address.log",
            "collect": "collect.log",
        }
        filename = mapping.get(name, "app.log")
        logger.addHandler(_make_handler(filename))
    return logger


recharge_logger = get_logger("recharge")
redpacket_logger = get_logger("redpacket")
user_click_logger = get_logger("user_click")
withdraw_logger = get_logger("withdraw")
password_logger = get_logger("password")
address_logger = get_logger("address")
collect_logger = get_logger("collect")
app_logger = get_logger("app")


=== src/main.py ===
# src/main.py
from telegram import BotCommand
from telegram.ext import (
    ApplicationBuilder,
    CallbackQueryHandler,
    CommandHandler,
    MessageHandler,
    filters,
)

from .config import BOT_TOKEN
from .handlers import addr_query as h_addrq
from .handlers import password as h_pwd
from .handlers import recharge as h_recharge
from .handlers import red_packet as h_rp
from .handlers import wallet as h_wallet
from .handlers import withdraw as h_withdraw

# ä»…å¤„ç†ç§èŠçš„ filter
PRIVATE = filters.ChatType.PRIVATE


async def on_startup(app):
    # åœ¨ post_init å›è°ƒé‡Œè®¾ç½®èœå•å‘½ä»¤ï¼Œé¿å…æ¨¡å—é¡¶å±‚ await
    await app.bot.set_my_commands(
        [
            BotCommand("start", "å¼€å§‹ä½¿ç”¨"),
            BotCommand("wallet", "æˆ‘çš„é’±åŒ…"),
            BotCommand("recharge", "å……å€¼"),
            BotCommand("withdraw", "æç°"),
            BotCommand("redpacket", "çº¢åŒ…"),
            BotCommand("help", "å¸®åŠ©"),
        ]
    )


def build_app():
    app = ApplicationBuilder().token(BOT_TOKEN).post_init(on_startup).build()

    # å‘½ä»¤
    app.add_handler(CommandHandler(["start", "wallet"], h_wallet.my_wallet, PRIVATE))
    app.add_handler(CommandHandler("recharge", h_recharge.show_recharge, PRIVATE))
    app.add_handler(CommandHandler("withdraw", h_withdraw.withdraw_entry, PRIVATE))
    app.add_handler(CommandHandler("redpacket", h_rp.entry_menu, PRIVATE))
    app.add_handler(CommandHandler("set_password", h_pwd.start_set_password, PRIVATE))
    app.add_handler(CommandHandler("help", h_wallet.help_text, PRIVATE))

    # å›è°ƒæŒ‰é’®
    app.add_handler(
        CallbackQueryHandler(
            h_recharge.recharge_callback,
            PRIVATE & filters.regex(r"^(recharge_|back_to_menu)"),
        )
    )
    app.add_handler(
        CallbackQueryHandler(h_rp.type_callback, PRIVATE & filters.regex(r"^rp_type:"))
    )
    app.add_handler(
        CallbackQueryHandler(
            h_pwd.password_kb_callback,
            PRIVATE & filters.regex(r"^pwd:(?:\d|ok|back|vis)$"),
        )
    )

    # åœ°å€æŸ¥è¯¢ï¼šç”¨æˆ·è¾“å…¥åœ°å€æ–‡æœ¬
    app.add_handler(
        MessageHandler(PRIVATE & filters.TEXT & ~filters.COMMAND, h_addrq.on_text)
    )

    return app


def main():
    app = build_app()
    app.run_polling(close_loop=False)


if __name__ == "__main__":
    main()


=== src/models.py ===
import random
import string
from datetime import datetime
from typing import Any, Dict, List, Optional

from .db import execute, fetchall, fetchone  # å¯¼å‡º execute ä¾›å…¶ä»–æ¨¡å—ä½¿ç”¨

# =========================
# å°å·¥å…·
# =========================


def _rand_letters(n: int = 4) -> str:
    return "".join(random.choice(string.ascii_lowercase) for _ in range(n))


# ---------- ç”¨æˆ· ----------
async def get_or_create_user(tg_id: int, username: str) -> Dict[str, Any]:
    row = await fetchone(
        "SELECT id, tg_id, username FROM users WHERE tg_id=%s", (tg_id,)
    )
    if not row:
        await execute(
            "INSERT INTO users(tg_id, username, usdt_trc20) VALUES(%s,%s,0)",
            (tg_id, (username or "")[:64]),
        )
        row = await fetchone(
            "SELECT id, tg_id, username FROM users WHERE tg_id=%s", (tg_id,)
        )
    return row


async def get_user_balance(user_id: int) -> float:
    row = await fetchone("SELECT usdt_trc20 FROM users WHERE id=%s", (user_id,))
    return float(row["usdt_trc20"] or 0) if row else 0.0


async def set_user_balance(user_id: int, new_balance: float) -> None:
    await execute("UPDATE users SET usdt_trc20=%s WHERE id=%s", (new_balance, user_id))


# =========================
# å……å€¼è®¢å•ï¼ˆrecharge_ordersï¼‰
# =========================
async def get_recharge_orders_by_status(status_list: List[str]) -> List[Dict[str, Any]]:
    if not status_list:
        return []
    ph = ",".join(["%s"] * len(status_list))
    sql = f"SELECT * FROM recharge_orders WHERE status IN ({ph}) ORDER BY id ASC"
    return await fetchall(sql, tuple(status_list))


def make_order_no(dt: Optional[datetime] = None) -> str:
    """
    è®¢å•å·è§„åˆ™ï¼šYYYYMMDDHHMM + 4ä½å°å†™å­—æ¯ï¼Œå¦‚ 202510151945abcd
    """
    dt = dt or datetime.now()
    return dt.strftime("%Y%m%d%H%M") + _rand_letters(4)


async def get_active_recharge_order(user_id: int) -> Optional[Dict[str, Any]]:
    return await fetchone(
        "SELECT * FROM recharge_orders "
        "WHERE user_id=%s AND status='waiting' AND expire_at>NOW() "
        "ORDER BY id DESC LIMIT 1",
        (user_id,),
    )


async def create_recharge_order(
    user_id: int, address: str, expected_amount: Optional[float], expire_minutes: int
) -> int:
    order_no = make_order_no()
    sql = (
        "INSERT INTO recharge_orders(order_no, user_id, address, expected_amount, status, created_at, expire_at) "
        "VALUES(%s,%s,%s,%s,'waiting',NOW(), DATE_ADD(NOW(), INTERVAL %s MINUTE))"
    )
    new_id = await execute(
        sql, (order_no, user_id, address, expected_amount, expire_minutes)
    )
    return new_id


async def get_recharge_order(order_id: int) -> Optional[Dict[str, Any]]:
    return await fetchone("SELECT * FROM recharge_orders WHERE id=%s", (order_id,))


async def list_recharge_waiting() -> List[Dict[str, Any]]:
    return await fetchall(
        "SELECT * FROM recharge_orders WHERE status='waiting' AND expire_at>NOW() ORDER BY id ASC LIMIT 100",
        (),
    )


async def list_recharge_collecting() -> List[Dict[str, Any]]:
    return await fetchall(
        "SELECT * FROM recharge_orders WHERE status='collecting' ORDER BY id ASC LIMIT 100",
        (),
    )


async def list_recharge_verifying() -> List[Dict[str, Any]]:
    return await fetchall(
        "SELECT * FROM recharge_orders WHERE status='verifying' ORDER BY id ASC LIMIT 100",
        (),
    )


async def set_recharge_status(order_id: int, status: str, txid: Optional[str]) -> None:
    if txid:
        await execute(
            "UPDATE recharge_orders SET status=%s, txid=%s, updated_at=NOW() WHERE id=%s",
            (status, txid, order_id),
        )
    else:
        await execute(
            "UPDATE recharge_orders SET status=%s, updated_at=NOW() WHERE id=%s",
            (status, order_id),
        )


async def ledger_exists_for_ref(ref_type: str, ref_table: str, ref_id: int) -> bool:
    row = await fetchone(
        "SELECT id FROM ledger WHERE ref_type=%s AND ref_table=%s AND ref_id=%s LIMIT 1",
        (ref_type, ref_table, ref_id),
    )
    return bool(row)


# =========================
# ç”¨æˆ· / äº¤æ˜“å¯†ç ï¼ˆusersï¼‰
# =========================


async def ensure_user(
    user_id: int,
    username: Optional[str],
    first_name: Optional[str],
    last_name: Optional[str],
):
    await execute(
        "INSERT IGNORE INTO users(id, username, first_name, last_name, created_at) "
        "VALUES(%s,%s,%s,%s,NOW())",
        (user_id, username, first_name, last_name),
    )


async def get_user(user_id: int) -> Optional[Dict[str, Any]]:
    return await fetchone("SELECT * FROM users WHERE id=%s", (user_id,))


async def get_tx_password_hash(user_id: int) -> Optional[str]:
    row = await fetchone("SELECT tx_password_hash FROM users WHERE id=%s", (user_id,))
    return row.get("tx_password_hash") if row else None


async def has_tx_password(tg_id: int) -> bool:
    row = await fetchone("SELECT tx_password_hash FROM users WHERE tg_id=%s", (tg_id,))
    return bool(row and row.get("tx_password_hash"))


async def set_tx_password_hash(tg_id: int, h: str) -> None:
    await execute("UPDATE users SET tx_password_hash=%s WHERE tg_id=%s", (h, tg_id))


# =========================
# é’±åŒ…ï¼ˆuser_walletsï¼‰
# =========================


async def get_wallet(user_id: int) -> Optional[Dict[str, Any]]:
    return await fetchone("SELECT * FROM user_wallets WHERE user_id=%s", (user_id,))


async def set_tron_wallet(user_id: int, address: str, privkey_enc: str):
    await execute(
        "INSERT INTO user_wallets(user_id, tron_address, tron_privkey_enc, usdt_trc20_balance) "
        "VALUES(%s,%s,%s,0) "
        "ON DUPLICATE KEY UPDATE tron_address=VALUES(tron_address), tron_privkey_enc=VALUES(tron_privkey_enc)",
        (user_id, address, privkey_enc),
    )


async def update_wallet_balance(user_id: int, new_bal: float):
    await execute(
        "UPDATE user_wallets SET usdt_trc20_balance=%s WHERE user_id=%s",
        (new_bal, user_id),
    )


# =========================
# è´¦å˜ï¼ˆledgerï¼‰
# =========================


async def add_ledger(
    user_id: int,
    change_type: str,  # 'recharge' | 'withdraw' | 'redpacket_send' | 'redpacket_claim' | 'adjust'
    amount: float,
    balance_before: float,
    balance_after: float,
    ref_table: Optional[str] = None,
    ref_type: Optional[str] = None,
    ref_id: Optional[int] = None,
    remark: Optional[str] = None,
) -> None:
    await execute(
        "INSERT INTO ledger(user_id, change_type, ref_table, amount, balance_before, balance_after, "
        "ref_type, ref_id, remark, created_at) "
        "VALUES(%s,%s,%s,%s,%s,%s,%s,%s,%s,NOW())",
        (
            user_id,
            change_type,
            ref_table,
            amount,
            balance_before,
            balance_after,
            ref_type,
            ref_id,
            (remark or "")[:255],
        ),
    )


async def list_ledger_recent(user_id: int, limit: int = 10) -> List[Dict[str, Any]]:
    return await fetchall(
        "SELECT * FROM ledger WHERE user_id=%s ORDER BY id DESC LIMIT %s",
        (user_id, limit),
    )


# =========================
# åœ°å€ç°¿ï¼ˆuser_addressesï¼‰
# =========================


async def list_user_addresses(user_id: int) -> List[Dict[str, Any]]:
    return await fetchall(
        "SELECT * FROM user_addresses WHERE user_id=%s ORDER BY id DESC", (user_id,)
    )


async def add_user_address(user_id: int, address: str, alias: str) -> int:
    """
    æ–°å¢å¸¸ç”¨åœ°å€ï¼›å»ºè®®åœ¨ä¸Šå±‚æ ¡éªŒåˆ«åé•¿åº¦<=15ã€TRON åœ°å€æ ¼å¼ç­‰ã€‚
    è¡¨ç»“æ„ï¼šuser_addresses(id PK AI, user_id, address, alias, created_at)
    """
    return await execute(
        "INSERT INTO user_addresses(user_id, address, alias, created_at) VALUES(%s,%s,%s,NOW())",
        (user_id, address, alias),
    )


async def delete_user_address(addr_id: int, user_id: int) -> None:
    await execute(
        "DELETE FROM user_addresses WHERE id=%s AND user_id=%s", (addr_id, user_id)
    )


async def get_user_address_by_alias(
    user_id: int, alias: str
) -> Optional[Dict[str, Any]]:
    return await fetchone(
        "SELECT * FROM user_addresses WHERE user_id=%s AND alias=%s", (user_id, alias)
    )


# =========================
# çº¢åŒ…ï¼ˆred_packets, red_packet_sharesï¼‰
# =========================


async def list_red_packets(user_id: int, limit: int = 10) -> List[Dict[str, Any]]:
    return await fetchall(
        "SELECT * FROM red_packets WHERE user_id=%s ORDER BY id DESC LIMIT %s",
        (user_id, limit),
    )


async def create_red_packet(
    user_id: int,
    rp_type: str,
    total_amount: float,
    count: int,
    currency: Optional[str],
    cover_text: Optional[str],
    exclusive_user_id: Optional[int],
) -> int:
    currency = currency or "USDT-trc20"
    sql = (
        "INSERT INTO red_packets(user_id, type, total_amount, count, currency, cover_text, exclusive_user_id, status, created_at) "
        "VALUES(%s,%s,%s,%s,%s,%s,%s,'draft',NOW())"
    )
    new_id = await execute(
        sql,
        (
            user_id,
            rp_type,
            total_amount,
            count,
            currency,
            cover_text,
            exclusive_user_id,
        ),
    )
    return new_id


async def get_red_packet(rp_id: int) -> Optional[Dict[str, Any]]:
    return await fetchone("SELECT * FROM red_packets WHERE id=%s", (rp_id,))


async def set_red_packet_status(rp_id: int, status: str):
    await execute(
        "UPDATE red_packets SET status=%s, updated_at=NOW() WHERE id=%s",
        (status, rp_id),
    )


async def save_red_packet_share(rp_id: int, seq: int, amount: float):
    await execute(
        "INSERT INTO red_packet_shares(red_packet_id, seq, amount) VALUES(%s,%s,%s)",
        (rp_id, seq, amount),
    )


async def list_red_packet_shares(rp_id: int) -> List[Dict[str, Any]]:
    return await fetchall(
        "SELECT * FROM red_packet_shares WHERE red_packet_id=%s ORDER BY id ASC",
        (rp_id,),
    )


async def claim_share(rp_id: int, user_id: int) -> Optional[Dict[str, Any]]:
    """
    ç®€å•ä¸¤æ®µå¼é˜²å¹¶å‘ï¼š
    1) æŠ“ä¸€æ¡æœªé¢†å–ä»½é¢
    2) æŠ¢å ï¼ˆclaimed_by IS NULLï¼‰â†’ ç„¶åå†è¯»å–è¿”å›
    """
    row = await fetchone(
        "SELECT id FROM red_packet_shares WHERE red_packet_id=%s AND claimed_by IS NULL ORDER BY id ASC LIMIT 1",
        (rp_id,),
    )
    if not row:
        return None
    sid = row["id"]
    await execute(
        "UPDATE red_packet_shares SET claimed_by=%s, claimed_at=NOW() WHERE id=%s AND claimed_by IS NULL",
        (user_id, sid),
    )
    got = await fetchone("SELECT * FROM red_packet_shares WHERE id=%s", (sid,))
    if not got or got.get("claimed_by") != user_id:
        return None
    return got


async def count_claimed(rp_id: int) -> int:
    row = await fetchone(
        "SELECT COUNT(*) AS c FROM red_packet_shares WHERE red_packet_id=%s AND claimed_by IS NOT NULL",
        (rp_id,),
    )
    return int(row["c"] if row else 0)


# å…¼å®¹æ—§ä»£ç ï¼šæœ‰çš„åœ°æ–¹å¼•äº† add_red_packet_claimï¼Œè¿™é‡Œæä¾›ç©ºå®ç°é¿å… ImportError
async def add_red_packet_claim(*args, **kwargs):
    return 0


# â€”â€” èƒ½é‡ç§Ÿç”¨è®°å½• â€”â€” #
async def last_energy_rent_seconds_ago(address: str) -> int:
    row = await fetchone(
        "SELECT TIMESTAMPDIFF(SECOND, rented_at, NOW()) AS sec FROM energy_rent_logs "
        "WHERE address=%s ORDER BY id DESC LIMIT 1",
        (address,),
    )
    if not row or row.get("sec") is None:
        return 10**9
    return int(row["sec"])


async def has_active_energy_rent(address: str) -> bool:
    row = await fetchone(
        "SELECT id FROM energy_rents WHERE address=%s AND expires_at > NOW() LIMIT 1",
        (address,),
    )
    return bool(row)


async def add_energy_rent_log(
    address: str,
    order_id: int,
    order_no: str,
    rent_order_id: Optional[str] = None,
    ttl_seconds: int = 3600,
) -> None:
    # FROM_UNIXTIME(UNIX_TIMESTAMP(NOW()) + %s) å…¼å®¹ 5.7
    await execute(
        "INSERT INTO energy_rents(address, order_id, order_no, rent_order_id, expires_at, created_at) "
        "VALUES(%s,%s,%s,%s, FROM_UNIXTIME(UNIX_TIMESTAMP(NOW()) + %s), NOW())",
        (address, order_id, order_no, rent_order_id, int(ttl_seconds)),
    )


async def mark_energy_rent_used(address: str) -> None:
    await execute(
        "UPDATE energy_rent_logs SET status='used' WHERE address=%s AND status='active'",
        (address,),
    )


async def get_flag(key: str) -> bool:
    row = await fetchone("SELECT v FROM sys_flags WHERE k=%s", (key,))
    return str(row["v"]).strip() == "1" if row else False


async def set_flag(key: str, on: bool) -> None:
    v = "1" if on else "0"
    # MySQL 5.7 æ²¡æœ‰æ ‡å‡† UPSERTï¼Œç”¨ ON DUPLICATE KEY
    await execute(
        "INSERT INTO sys_flags(k,v) VALUES(%s,%s) "
        "ON DUPLICATE KEY UPDATE v=VALUES(v), updated_at=NOW()",
        (key, v),
    )


async def sum_user_usdt_balance() -> float:
    row = await fetchone("SELECT COALESCE(SUM(usdt_trc20),0) AS s FROM users", ())
    return float(row["s"] or 0)


async def get_ledger_amount_by_ref(ref_type: str, ref_table: str, ref_id: int) -> float:
    row = await fetchone(
        "SELECT COALESCE(SUM(amount),0) AS s FROM ledger WHERE ref_type=%s AND ref_table=%s AND ref_id=%s",
        (ref_type, ref_table, ref_id),
    )
    return float(row["s"] or 0)


=== src/services/encryption.py ===
from cryptography.fernet import Fernet

from ..config import FERNET_KEY

_cipher = Fernet(FERNET_KEY.encode() if isinstance(FERNET_KEY, str) else FERNET_KEY)


def encrypt_text(s: str) -> str:
    return _cipher.encrypt(s.encode()).decode()


def decrypt_text(token: str) -> str:
    return _cipher.decrypt(token.encode()).decode()


=== src/services/energy.py ===
# src/services/energy.py
import os
import re
from typing import Any, Dict, Optional

import httpx

from ..config import TRONGAS_API_KEY
from ..logger import collect_logger

API_URL = "https://trongas.io/api/batchPay"


def _normalize_paynums(n: int) -> int:
    """
    å°†è¯·æ±‚é‡ n å½’ä¸€åŒ–åˆ° >= æœ€å°ç§Ÿç”¨é‡ï¼Œä¸”æŒ‰æ­¥é•¿å‘ä¸Šå–æ•´ã€‚
    TRONGAS_MIN_RENT é»˜è®¤ 32000ï¼ŒTRONGAS_RENT_STEP é»˜è®¤ 1000ã€‚
    """
    min_rent = int(os.getenv("TRONGAS_MIN_RENT", "32000"))
    step = max(int(os.getenv("TRONGAS_RENT_STEP", "1000")), 1)
    n = max(int(n), min_rent)
    n = ((n + step - 1) // step) * step
    return n


def _safe_notes(s: Optional[str]) -> str:
    """
    å¤‡æ³¨åªå…è®¸ï¼šæ±‰å­— / å­—æ¯ / æ•°å­— / ä¸‹åˆ’çº¿ _ / ç ´æŠ˜å· -
    å¹¶é™åˆ¶é•¿åº¦ï¼ˆ<=32ï¼‰ï¼Œé˜²æ­¢è§¦å‘ trongas æ ¡éªŒã€‚
    """
    s = s or ""
    s = re.sub(r"[^0-9A-Za-z_\-\u4e00-\u9fff]", "", s)
    s = s[:32]
    return s or "hb"


async def rent_energy(
    receive_address: str,
    pay_nums: int = 65000,
    rent_time: int = 1,
    order_notes: Optional[str] = None,
) -> Dict[str, Any]:
    """
    è°ƒç”¨ trongas èƒ½é‡ç§Ÿç”¨æ¥å£ï¼ˆä»…ä½¿ç”¨ apiKeyï¼‰ã€‚
    - å•æ¬¡æœ€å° 32000ï¼ŒæŒ‰æ­¥é•¿å–æ•´ï¼ˆé»˜è®¤ 1000ï¼‰ã€‚
    - å¤‡æ³¨å­—ç¬¦åˆè§„ã€‚
    """
    if not TRONGAS_API_KEY:
        raise RuntimeError("TRONGAS_API_KEY æœªé…ç½®ï¼Œæ— æ³•ç§Ÿç”¨èƒ½é‡")

    pay_nums = _normalize_paynums(pay_nums)
    order_notes = _safe_notes(order_notes)

    payload = {
        "apiKey": TRONGAS_API_KEY,
        "payNums": int(pay_nums),
        "rentTime": int(rent_time),
        "receiveAddress": receive_address,
        "orderNotes": order_notes,
    }

    collect_logger.info(
        f"âš¡ æ­£åœ¨è¯·æ±‚ç§Ÿç”¨èƒ½é‡ï¼špayNums={pay_nums}, rentTime={rent_time}, addr={receive_address}, notes='{order_notes}'"
    )

    async with httpx.AsyncClient(timeout=30) as client:
        r = await client.post(API_URL, json=payload)
        r.raise_for_status()
        data = r.json()
        # ç»Ÿä¸€é”™è¯¯æŠ›å‡ºï¼ˆä¿ç•™æœåŠ¡ç«¯ code/msgï¼‰
        if data.get("code") != 10000:
            raise RuntimeError(
                f"trongas ä¸‹å•å¤±è´¥ï¼šcode={data.get('code')} msg={data.get('msg')}"
            )
        return data.get("data", {})


=== src/services/qrcode_util.py ===
# src/services/qrcode_util.py
import io
from typing import Optional

import qrcode
from PIL import Image, ImageDraw, ImageFont


def make_qr_png_bytes(
    data: str, scale: float = 0.5, caption: Optional[str] = None
) -> bytes:
    # ç”ŸæˆäºŒç»´ç 
    qr = qrcode.QRCode(border=2, box_size=10)
    qr.add_data(data)
    qr.make(fit=True)
    img = qr.make_image(fill_color="black", back_color="white").convert("RGB")

    # ç¼©æ”¾
    if 0 < scale < 1.0:
        w, h = img.size
        img = img.resize((int(w * scale), int(h * scale)), Image.LANCZOS)

    # å åŠ åœ°å€æ–‡å­—ï¼ˆè‡ªåŠ¨æ¢è¡Œï¼‰
    if caption:
        pad = 16
        W, H = img.size
        font = ImageFont.load_default()
        draw = ImageDraw.Draw(img)

        # ç®€å•æŒ‰å®½åº¦æˆªæ–­æ¢è¡Œ
        lines, cur, maxw = [], "", W - 20
        for ch in caption:
            trial = cur + ch
            if draw.textlength(trial, font=font) > maxw:
                lines.append(cur)
                cur = ch
            else:
                cur = trial
        if cur:
            lines.append(cur)

        line_h = 14
        text_h = line_h * len(lines) + pad
        canvas = Image.new("RGB", (W, H + text_h), "white")
        canvas.paste(img, (0, 0))
        draw = ImageDraw.Draw(canvas)
        y = H + (pad // 2)
        for ln in lines:
            draw.text((10, y), ln, fill="black", font=font)
            y += line_h
        img = canvas

    # è¾“å‡º PNG
    buf = io.BytesIO()
    img.save(buf, format="PNG")
    return buf.getvalue()


=== src/services/redalgo.py ===
import random
from decimal import Decimal, getcontext
from typing import List

# ä½¿ç”¨ 6 ä½å°æ•°ï¼Œé€‚é… USDT å¸¸è§ç²¾åº¦
getcontext().prec = 28


def _d(x) -> Decimal:
    if isinstance(x, Decimal):
        return x
    return Decimal(str(x))


def split_random(total_amount: float, count: int) -> List[Decimal]:
    """
    éšæœºçº¢åŒ…ï¼š
    - å•ä»½æœ€å¤§ä¸è¶…è¿‡ 2 * (å‡å€¼)
    - æ€»å’Œä¸¥æ ¼ç­‰äº total_amount
    - é¿å…å‡ºç° 0 æˆ–æœ€åä¸€ä»½è¿‡å¤§çš„æƒ…å†µ
    """
    assert count >= 1
    total = _d(total_amount)
    mean = total / _d(count)
    max_per = mean * _d(2)  # æœ€å¤§å€¼é™åˆ¶
    shares = []
    remain = total

    for i in range(1, count + 1):
        remain_count = count - len(shares)
        if remain_count == 1:
            # æœ€åä¸€ä»½
            amt = remain
        else:
            # å‰©ä½™å‡å€¼é™„è¿‘éšæœºï¼Œé™åˆ¶ä¸Šé™ä¸ä¸‹é™
            max_allowed = min(max_per, remain - _d("0.000001") * (remain_count - 1))
            min_allowed = max(_d("0.000001"), remain / _d(remain_count) / _d(2))
            if max_allowed < min_allowed:
                max_allowed = min_allowed
            # åœ¨ [min_allowed, max_allowed] é—´éšæœº
            r = Decimal(str(random.random()))
            amt = min_allowed + r * (max_allowed - min_allowed)
            # å››èˆäº”å…¥åˆ° 6 ä½å°æ•°
            amt = amt.quantize(Decimal("0.000001"))
            if amt <= _d("0"):
                amt = _d("0.000001")
        remain -= amt
        remain = remain.quantize(Decimal("0.000001"))
        shares.append(amt)

    # ä¿®æ­£æ€»å’Œè¯¯å·®
    diff = total - sum(shares)
    if diff != 0:
        shares[-1] = (shares[-1] + diff).quantize(Decimal("0.000001"))
        if shares[-1] <= 0:
            # æç«¯å›é€€ï¼Œé‡æ–°å¹³æ‘Š
            return split_average(total_amount, count)

    return shares


def split_average(total_amount: float, count: int) -> List[Decimal]:
    total = _d(total_amount)
    base = (total / _d(count)).quantize(Decimal("0.000001"))
    shares = [base for _ in range(count)]
    # è°ƒæ•´å°æ•°è¯¯å·®
    diff = total - sum(shares)
    shares[-1] = (shares[-1] + diff).quantize(Decimal("0.000001"))
    return shares


=== src/services/tron.py ===
import asyncio
import os
import random
import re
import time
from dataclasses import dataclass
from decimal import Decimal
from typing import Dict, List, Optional, Union
from decimal import Decimal as _Decimal
from typing import Optional as _Optional

import requests
from tronpy import Tron
from tronpy.exceptions import TransactionNotFound
from tronpy.keys import PrivateKey
from tronpy.providers import HTTPProvider

from ..config import (
    TRON_FULLNODE_URL,
    TRONGRID_API_KEY,
    TRONGRID_QPS,
    USDT_CONTRACT,
    USDT_DECIMALS,
)
from ..logger import collect_logger

TRON_GRID_KEYS = [
    k.strip() for k in os.getenv("TRONGRID_API_KEY", "").split(",") if k.strip()
]

async def get_trc20_balance(address: str, contract_address: str) -> _Decimal:
    """
    æŸ¥è¯¢ä»»æ„ TRC-20 åˆçº¦ä½™é¢ï¼›è¿”å› Decimal é‡‘é¢ï¼ŒæŒ‰åˆçº¦ decimals å¤„ç†ã€‚
    ä¸å·²æœ‰ä»£ç å…¼å®¹ï¼šawait get_trc20_balance(addr, USDT_CONTRACT)
    """
    import asyncio

    def _task() -> _Decimal:
        # ä¾èµ–ç°æœ‰ tron.py çš„ _get_client()ï¼Œä¸è¦æ”¹åŠ¨ä½ çš„è¿æ¥/é™æµç­–ç•¥
        c = _get_client()  # è‹¥ä½ çš„ tron å®¢æˆ·ç«¯æ„é€ å‡½æ•°åä¸åŒï¼Œè¯·æ”¹æˆä½ è‡ªå·±çš„
        ctr = c.get_contract(contract_address)
        raw = ctr.functions.balanceOf(address)  # int
        try:
            decimals = int(ctr.functions.decimals())
        except Exception:
            decimals = 6  # USDT é»˜è®¤ä¸º 6ï¼›å–ä¸åˆ°å°±ä¿å®ˆæŒ‰ 6
        return _Decimal(raw) / (_Decimal(10) ** decimals)

    loop = asyncio.get_running_loop()
    return await loop.run_in_executor(None, _task)



def _tg_headers(ix: int):
    h = {"Accept": "application/json"}
    if TRON_GRID_KEYS:
        h["TRON-PRO-API-KEY"] = TRON_GRID_KEYS[ix % len(TRON_GRID_KEYS)]
    return h


def _tg_get(url, params=None, tries=3, backoff=0.7):
    for i in range(tries):
        r = requests.get(url, params=params or {}, headers=_tg_headers(i), timeout=15)
        if r.status_code == 429:
            time.sleep(backoff * (i + 1))
            continue
        r.raise_for_status()
        return r.json()
    raise RuntimeError("TronGrid 429/å¤±è´¥è¿‡å¤š")


async def get_recent_transfers(address: str, limit: int = 10) -> List[Dict]:
    url = f"https://api.trongrid.io/v1/accounts/{address}/transactions/trc20"
    js = _tg_get(url, params={"limit": limit})
    out = []
    for it in js.get("data", []):
        v = it.get("value", {})
        if not v:
            continue
        out.append(
            {
                "hash": it.get("transaction_id", ""),
                "from": v.get("from", ""),
                "to": v.get("to", ""),
                "amount": float(v.get("value", 0)) / (10 ** int(v.get("decimal", 6))),
                "asset": v.get("symbol", "USDT"),
            }
        )
    return out


def get_trx_balance(address: str) -> float:
    """
    è¯»å–åœ°å€TRXä½™é¢ï¼ˆå•ä½ï¼šTRXï¼‰
    """
    c = _get_client()
    acc = c.get_account(address)  # dictï¼›balance ä¸º Sun
    bal_sun = int(acc.get("balance", 0))
    return bal_sun / 1_000_000.0


def wait_tx_committed(txid: str, timeout: int = 45, interval: float = 1.5) -> dict:
    """
    è½®è¯¢æŸ¥è¯¢äº¤æ˜“ä¿¡æ¯ï¼Œç›´åˆ°è¿”å›ç»“æœæˆ–è¶…æ—¶ã€‚
    è¿”å› info å­—å…¸ï¼›è‹¥ info.get('result') == 'FAILED' åˆ™è§†ä¸ºå¤±è´¥ã€‚
    """
    c = _get_client()
    deadline = time.time() + timeout
    last_err = None
    while time.time() < deadline:
        try:
            info = c.get_transaction_info(txid)
            # TRX æ™®é€šè½¬è´¦å¯èƒ½æ²¡æœ‰ contractRetï¼›å‡ºç° 'result': 'SUCCESS' æˆ–åŒ…å« blockNumber å³å¯è§†ä¸ºæˆåŠŸ
            if info and (
                info.get("result") == "SUCCESS" or info.get("blockNumber") is not None
            ):
                return info
            # æœ‰æ˜ç¡®å¤±è´¥
            if info and info.get("result") == "FAILED":
                return info
        except TransactionNotFound as e:
            last_err = e
        time.sleep(interval)
    # è¶…æ—¶ä¹Ÿè¿”å›æœ€åä¸€æ¬¡è·å–åˆ°çš„ info æˆ–æŠ›å‡º
    if last_err:
        raise last_err
    return {}


@dataclass
class TronAddress:
    address: str
    private_key_hex: str  # 64 hex


# ========== åŸºç¡€å·¥å…·ï¼šå…¨å±€å¼‚æ­¥é™é€Ÿ ==========
class AsyncRateLimiter:
    """ç®€å•çš„æœ€å°é—´éš”é™é€Ÿå™¨ï¼ŒæŒ‰ QPS è®¡ç®—è°ƒç”¨é—´éš”"""

    def __init__(self, qps: float):
        self.interval = 1.0 / max(qps, 0.1)
        self._last = 0.0
        self._lock = asyncio.Lock()

    async def wait(self):
        async with self._lock:
            now = time.monotonic()
            wait_for = self.interval - (now - self._last)
            if wait_for > 0:
                await asyncio.sleep(wait_for)
            self._last = time.monotonic()


_limiter = AsyncRateLimiter(TRONGRID_QPS)


def _parse_keys(raw: str) -> Optional[Union[str, List[str]]]:
    if not raw:
        return None
    ks = [k.strip() for k in raw.split(",") if k.strip()]
    if not ks:
        return None
    return ks if len(ks) > 1 else ks[0]


def _get_client() -> Tron:
    """åˆ›å»º Tron å®¢æˆ·ç«¯ï¼›å¸¦ TronGrid API Keyï¼ˆæ”¯æŒå¤šä¸ª Key è½®æ¢ï¼‰"""
    api_keys = _parse_keys(TRONGRID_API_KEY)
    provider = HTTPProvider(
        endpoint_uri=TRON_FULLNODE_URL or "https://api.trongrid.io",
        api_key=api_keys,
        timeout=20.0,
    )
    return Tron(provider)


def get_account_resource(address: str) -> dict:
    """
    è¿”å› {'bandwidth': int, 'energy': int}
    å¸¦å®½ = (freeNetLimit - freeNetUsed) + (NetLimit - NetUsed)
    èƒ½é‡ = (EnergyLimit - EnergyUsed)
    """
    c = _get_client()
    info = c.get_account_resource(address)
    bw = max(
        0, int(info.get("freeNetLimit", 0)) - int(info.get("freeNetUsed", 0))
    ) + max(0, int(info.get("NetLimit", 0)) - int(info.get("NetUsed", 0)))
    en = max(0, int(info.get("EnergyLimit", 0)) - int(info.get("EnergyUsed", 0)))
    return {"bandwidth": bw, "energy": en}


def send_trx(priv_hex: str, from_addr: str, to_addr: str, amount_trx: float) -> str:
    c = _get_client()
    amt_sun = int(Decimal(str(amount_trx)) * Decimal(1_000_000))
    tx = (
        c.trx.transfer(from_addr, to_addr, amt_sun)
        .build()
        .sign(PrivateKey(bytes.fromhex(priv_hex)))
        .broadcast()
    )
    txid = tx.txid
    info = wait_tx_committed(txid, timeout=45)
    # åˆ¤å®šæˆåŠŸï¼šæœ‰å—å·ä¸”æœªæ ‡è®° FAILED
    if info and info.get("result") != "FAILED" and info.get("blockNumber") is not None:
        return txid
    raise RuntimeError(f"TRX topup not confirmed: {info or 'no-info'} txid={txid}")


def generate_address() -> TronAddress:
    """ä»…ç”¨äºå ä½/åˆå§‹åŒ–ï¼Œç”Ÿäº§ä¸Šè¯·ä½¿ç”¨ä½ ç°æœ‰çš„åŠ å¯†ç§é’¥æ–¹æ¡ˆ"""
    pk = PrivateKey.random()
    return TronAddress(
        address=pk.public_key.to_base58check_address(),
        private_key_hex=pk.hex(),
    )


async def _retry_with_backoff(coro_func, *args, **kwargs):
    """
    æŒ‡æ•°é€€é¿é‡è¯•ï¼šå¤„ç† 401/403/429 æˆ– requests.HTTPError
    å›é€€ï¼š1s / 2s / 4s / 8sï¼ˆå åŠ è½»å¾®æŠ–åŠ¨ï¼‰
    """
    for attempt in range(4):
        try:
            return await coro_func(*args, **kwargs)
        except Exception as e:
            code = getattr(getattr(e, "response", None), "status_code", None)
            if code in (401, 403, 429) or isinstance(e, requests.HTTPError):
                delay = (2**attempt) + random.uniform(0, 0.5)
                collect_logger.warning(
                    f"[TronGrid] å—é™/æœªæˆæƒï¼Œé‡è¯• {attempt+1}/4ï¼Œ{delay:.2f}s åé‡è¯•ï¼›err={e}"
                )
                await asyncio.sleep(delay)
                continue
            raise


async def get_usdt_balance(address: str) -> float:
    async def _call():
        await _limiter.wait()

        def _task():
            c = _get_client()
            usdt = c.get_contract(USDT_CONTRACT)
            raw = usdt.functions.balanceOf(address)
            return float(Decimal(raw) / (Decimal(10) ** USDT_DECIMALS))

        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(None, _task)

    return await _retry_with_backoff(_call)


async def usdt_transfer_all(
    priv_hex: str, from_addr: str, to_addr: str, amount: float
) -> str:
    """
    å°† amount USDT ä» from_addr è½¬åˆ° to_addrï¼Œç­‰å¾…ç¡®è®¤ï¼Œè¿”å› txid
    å¦‚æœå›æ‰§ä¸æ˜¯ SUCCESSï¼ˆå¦‚ OUT_OF_ENERGY / REVERT ç­‰ï¼‰ï¼Œç›´æ¥æŠ›å¼‚å¸¸ï¼Œè®©ä¸Šå±‚ä¿æŒ collecting çŠ¶æ€é‡è¯•ã€‚
    """

    async def _call():
        await _limiter.wait()

        def _task():
            c = _get_client()
            usdt = c.get_contract(USDT_CONTRACT)
            amt = int(Decimal(str(amount)) * (Decimal(10) ** USDT_DECIMALS))
            tx = (
                usdt.functions.transfer(to_addr, amt)
                .with_owner(from_addr)
                .fee_limit(30_000_000)
                .build()
                .sign(PrivateKey(bytes.fromhex(priv_hex)))
                .broadcast()
            )
            receipt = tx.wait()
            # å¸¸è§ä½ç½®ï¼šcontractResult/receipt/result/ret ç­‰ï¼›tronpy å›æ‰§ç»“æ„å¯èƒ½å› èŠ‚ç‚¹å·®å¼‚ç•¥ä¸åŒ
            result = (
                (receipt.get("receipt") or {}).get("result")
                or receipt.get("contractRet")
                or ""
            )
            result = str(result).upper()
            if result != "SUCCESS":
                raise RuntimeError(
                    f"transfer receipt not SUCCESS: {result}  txid={tx.txid}"
                )

            collect_logger.info(f"âœ… USDT è½¬è´¦ç¡®è®¤æˆåŠŸï¼štxid={tx.txid} result={result}")
            return tx.txid

        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(None, _task)

    return await _retry_with_backoff(_call)


# ========== åœ°å€æ ¡éªŒ ==========
# è½»é‡çº§æ ¼å¼æ ¡éªŒï¼šT å¼€å¤´ + 34 ä½ Base58 å­—ç¬¦ï¼ˆæ’é™¤ 0 O I lï¼‰
_BASE58_RE = re.compile(r"^T[1-9A-HJ-NP-Za-km-z]{33}$")


def is_valid_address(address: str) -> bool:
    """
    ä»…åš**å¿«é€Ÿæ ¼å¼æ ¡éªŒ**ï¼ˆBase58Check çš„å¼±æ ¡éªŒï¼‰ï¼š
    - ä»¥ 'T' å¼€å¤´
    - é•¿åº¦ 34
    - ä»…åŒ…å« Base58 å­—ç¬¦ï¼ˆæ’é™¤ 0 O I lï¼‰
    å¦‚æœéœ€è¦æ›´ä¸¥æ ¼çš„é“¾ä¸Šæ ¡éªŒï¼Œå¯åœ¨ä¸Šå±‚è°ƒç”¨ `get_usdt_balance(address)` ç­‰è¯»é“¾æ¥å£è¿›ä¸€æ­¥éªŒè¯ã€‚
    """
    if not isinstance(address, str):
        return False
    if not _BASE58_RE.match(address):
        return False
    return True


